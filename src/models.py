# generated by datamodel-codegen:
#   filename:  QuantConnect-Platform-2.0.0.yaml
#   timestamp: 2025-07-04T22:48:32+00:00

from __future__ import annotations
from pydantic import RootModel, ConfigDict

from datetime import date, datetime
from enum import Enum
from typing import Annotated, Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field


class Language(Enum):
    C_ = 'C#'
    Py = 'Py'


class BacktestInitResponse(BaseModel):
    state: Annotated[
        Optional[str],
        Field(description='State of the backtest (e.g. Error, End).', examples=['End']),
    ] = None
    version: Annotated[
        Optional[str], Field(description='Version of the response.', examples=[2.0])
    ] = None
    payload: Annotated[
        Optional[str],
        Field(description='Information about the backtest initialization.'),
    ] = None
    payloadType: Annotated[
        Optional[str],
        Field(description='Type of the payload, e.g. String.', examples=['String']),
    ] = None


class CodeCompletionRequest(BaseModel):
    language: Annotated[
        Language,
        Field(
            description='Programming language for the code completion.', examples=['Py']
        ),
    ]
    sentence: Annotated[
        str,
        Field(
            description='Sentence to complete.', examples=['self.add_equity(\\"AAPL\\"']
        ),
    ]
    responseSizeLimit: Annotated[
        Optional[int],
        Field(description='Maximum size of the responses.', examples=[10]),
    ] = None


class CodeCompletionResponse(BaseModel):
    state: Annotated[
        Optional[str],
        Field(description='State of the code completion.', examples=['End']),
    ] = None
    version: Annotated[
        Optional[str], Field(description='Version of the response.', examples=[2.0])
    ] = None
    payload: Annotated[
        Optional[List[str]], Field(description='Code completion suggestions.')
    ] = None
    payloadType: Annotated[
        Optional[str],
        Field(
            description='Type of the payload, e.g. StringArray.',
            examples=['StringArray'],
        ),
    ] = None


class ErrorEnhanceResponse(BaseModel):
    state: Annotated[
        Optional[str],
        Field(description='State of the code completion.', examples=['End']),
    ] = None
    version: Annotated[
        Optional[str], Field(description='Version of the response.', examples=[2.0])
    ] = None
    payload: Annotated[
        Optional[str], Field(description='Error message suggestions.')
    ] = None
    payloadType: Annotated[
        Optional[str],
        Field(description='Type of the payload, e.g. String.', examples=['String']),
    ] = None


class PEP8ConvertResponse(BaseModel):
    state: Annotated[
        Optional[str], Field(description='State of PEP8 conversion.', examples=['End'])
    ] = None
    version: Annotated[
        Optional[str], Field(description='Version of the response.', examples=[2.0])
    ] = None
    payload: Annotated[
        Optional[Any],
        Field(
            description='PEP8 converted code.',
            examples=[{'utils.py': 'def add(a,b):\n    return a+b\n'}],
        ),
    ] = None
    payloadType: Annotated[
        Optional[str],
        Field(
            description='Type of the payload, e.g. StringDict.', examples=['StringDict']
        ),
    ] = None


class SyntaxCheckResponse(BaseModel):
    state: Annotated[
        Optional[str], Field(description='State of the syntax check.', examples=['End'])
    ] = None
    version: Annotated[
        Optional[str], Field(description='Version of the response.', examples=[2.0])
    ] = None
    payload: Annotated[
        Optional[List[str]], Field(description='Code completion suggestions.')
    ] = None
    payloadType: Annotated[
        Optional[str],
        Field(
            description='Type of the payload, e.g. StringArray.',
            examples=['StringArray'],
        ),
    ] = None


class SearchCriteria(BaseModel):
    input: Annotated[
        Optional[str], Field(description='Input for the search.', examples=['option'])
    ] = None
    type: Annotated[
        Optional[str],
        Field(description='Type of the search criteria.', examples=['Docs']),
    ] = None
    count: Annotated[
        Optional[int], Field(description='Number of results to return.', examples=[1])
    ] = None


class SearchRetrieval(BaseModel):
    url: Annotated[
        Optional[str],
        Field(
            description='Input for the search.',
            examples=[
                'option[Index Options - QuantConnect.com](https://www.quantconnect.com/docs/v2/writing-algorithms/universes/index-options)'
            ],
        ),
    ] = None
    score: Annotated[
        Optional[float],
        Field(
            description='Relevance score of the search result.', examples=[0.320344448]
        ),
    ] = None
    content: Annotated[
        Optional[str], Field(description='Content of the search result.')
    ] = None
    type: Annotated[
        Optional[float], Field(description='Type of the search result.', examples=[2])
    ] = None


class AbortOptimizationRequest(BaseModel):
    optimizationId: Annotated[
        Optional[str],
        Field(
            description='Optimization ID we want to abort.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ] = None


class BacktestReport(BaseModel):
    report: Annotated[
        Optional[str],
        Field(description='HTML data of the report with embedded base64 images.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class BacktestReportRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Id of the project to read.', examples=[23456789])
    ]
    backtestId: Annotated[str, Field(description='Specific backtest Id to read.')]


class Status(Enum):
    Completed_ = 'Completed.'
    In_Queue___ = 'In Queue...'
    Running_____ = '\'Running: _%\''


class Environment(Enum):
    live = 'live'
    paper = 'paper'


class BaseLiveAlgorithmSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(
            description="'Interactive' / 'FXCM' / 'Oanda' / 'Tradier' /'PaperTrading'",
            examples=['Default'],
        ),
    ] = None
    user: Annotated[
        Optional[str],
        Field(description='Username associated with brokerage.', examples=['']),
    ] = None
    password: Annotated[
        Optional[str],
        Field(description='Password associated with brokerage.', examples=['']),
    ] = None
    environment: Annotated[
        Optional[Environment],
        Field(
            description='Represents the types of environments supported by brokerages for trading.'
        ),
    ] = None
    account: Annotated[
        Optional[str],
        Field(description='Account of the associated brokerage.', examples=['']),
    ] = None


class BitfinexSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='ID of the brokerage, this is, BitfinexBrokerage.'),
    ] = None
    bitfinex_api_key: Annotated[
        Optional[str],
        Field(alias='bitfinex-api-key', description='Your Bitfinex API key.'),
    ] = None
    bitfinex_api_secret: Annotated[
        Optional[str],
        Field(alias='bitfinex-api-secret', description='Your Bitfinex API secret.'),
    ] = None


class BrokerageId(BaseModel):
    id: Annotated[Optional[str], Field(description='The ID of the brokerage.')] = None


class BybitUseTestnet(Enum):
    live = 'live'
    paper = 'paper'


class Card(BaseModel):
    brand: Annotated[Optional[str], Field(description='Credit card brand.')] = None
    expiration: Annotated[
        Optional[str],
        Field(description='The credit card expiration (mm/yy).', examples=['12/27']),
    ] = None
    last4: Annotated[
        Optional[str], Field(description='The last 4 digits of the card.')
    ] = None


class Cash(BaseModel):
    symbol: Annotated[
        Optional[str], Field(description='Gets the symbol used to represent this cash.')
    ] = None
    amount: Annotated[
        Optional[float], Field(description='Gets or sets the amount of cash held.')
    ] = None
    conversionRate: Annotated[
        Optional[float],
        Field(description='The currency conversion rate to the account base currency.'),
    ] = None
    currencySymbol: Annotated[
        Optional[Any], Field(description='The symbol of the currency, such as $.')
    ] = None
    valueInAccountCurrency: Annotated[
        Optional[float],
        Field(
            description='The value of the currency cash in the account base currency.'
        ),
    ] = None


class CashAmount(BaseModel):
    amount: Annotated[Optional[float], Field(description='The amount of cash.')] = None
    currency: Annotated[
        Optional[str],
        Field(description='The currency in which the cash amount is denominated.'),
    ] = None


class ChartSummary(BaseModel):
    name: Annotated[Optional[str], Field(description='Name of the Chart.')] = None


class ChartType(Enum):
    Overlay = 'Overlay'
    Stacked = 'Stacked'


class ChartPoint(BaseModel):
    x: Annotated[
        Optional[str],
        Field(
            description='Time of this chart point: lower case for javascript encoding simplicty.'
        ),
    ] = None
    y: Annotated[
        Optional[float],
        Field(
            description='Value of this chart point:  lower case for javascript encoding simplicty.'
        ),
    ] = None


class CreateCompileRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Id of the project to compile.', examples=[23456789])
    ]


class Permission(Enum):
    read = 'read'
    write = 'write'


class Collaborator(BaseModel):
    uid: Annotated[Optional[int], Field(description='User ID.')] = None
    liveControl: Annotated[
        Optional[bool], Field(description='Indicate if the user has live control.')
    ] = None
    permission: Annotated[
        Optional[Permission], Field(description='The permission this user is given.')
    ] = None
    publicId: Annotated[Optional[str], Field(description='The user public ID.')] = None
    profileImage: Annotated[
        Optional[str],
        Field(
            description='The url of the user profile image.',
            examples=['https://cdn.quantconnect.com/web/i/users/profile/abc123.jpeg'],
        ),
    ] = None
    email: Annotated[
        Optional[str],
        Field(
            description='The registered email of the user.', examples=['abc@123.com']
        ),
    ] = None
    name: Annotated[
        Optional[str], Field(description='The display name of the user.')
    ] = None
    bio: Annotated[Optional[str], Field(description='The biography of the user.')] = (
        None
    )
    owner: Annotated[
        Optional[bool],
        Field(description='Indicate if the user is the owner of the project.'),
    ] = None


class CreateCollaboratorRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project to add the collaborator to.',
            examples=[23456789],
        ),
    ]
    collaboratorUserId: Annotated[
        str,
        Field(description='User Id of the collaborator to add.', examples=['mia-ai']),
    ]
    collaborationLiveControl: Annotated[
        bool,
        Field(
            description='Gives the right to deploy and stop live algorithms.',
            examples=[True],
        ),
    ]
    collaborationWrite: Annotated[
        bool, Field(description='Gives the right to edit the code.', examples=[False])
    ]


class CreateCollaboratorResponse(BaseModel):
    collaborators: Annotated[
        Optional[List[Collaborator]], Field(description='List of collaborators.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class ReadCollaboratorsRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read the collaborators.',
            examples=[23456789],
        ),
    ]


class ReadCollaboratorsResponse(BaseModel):
    collaborators: Annotated[
        Optional[List[Collaborator]],
        Field(description='List of collaborators on the project.'),
    ] = None
    userLiveControl: Annotated[
        Optional[bool],
        Field(
            description='Indicate if the user has the right to deploy and stop live algorithms.'
        ),
    ] = None
    userPermissions: Annotated[
        Optional[str], Field(description='List the user permissions - write/read')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class UpdateCollaboratorRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project the collaborator is on.', examples=[23456789]
        ),
    ]
    collaboratorUserId: Annotated[
        str,
        Field(
            description='User Id of the collaborator to update.', examples=['mia-ai']
        ),
    ]
    liveControl: Annotated[
        bool,
        Field(
            description='Gives the right to deploy and stop live algorithms.',
            examples=[True],
        ),
    ]
    write: Annotated[
        bool, Field(description='Gives the right to edit the code.', examples=[True])
    ]


class UpdateCollaboratorResponse(BaseModel):
    collaborators: Annotated[
        Optional[List[Collaborator]], Field(description='List of collaborators.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class DeleteCollaboratorRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project to remove the collaborator from.',
            examples=[23456789],
        ),
    ]
    collaboratorId: Annotated[
        str,
        Field(
            description='User Id of the collaborator to remove.', examples=['mia-ai']
        ),
    ]


class DeleteCollaboratorResponse(BaseModel):
    collaborators: Annotated[
        Optional[List[Collaborator]], Field(description='List of collaborators.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class State(Enum):
    InQueue = 'InQueue'
    BuildSuccess = 'BuildSuccess'
    BuildError = 'BuildError'


class ReadCompileResponse(BaseModel):
    compileId: Annotated[
        Optional[str],
        Field(
            description='Compile Id for a sucessful build.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ] = None
    state: Annotated[
        Optional[State], Field(description='The current state of the compile job.')
    ] = None
    logs: Annotated[
        Optional[List[str]], Field(description='Logs of the compilation request.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ParameterDetail(BaseModel):
    line: Annotated[
        Optional[int],
        Field(
            description='Line number where the parameter was detected.', examples=[8]
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='Description of the detected parameter.',
            examples=[
                '3 LEAN API parameters detected near "self.set_start_date(2024, 1, 3)".'
            ],
        ),
    ] = None


class CreateBacktestRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Project Id we sent for compile.', examples=[23456789])
    ]
    compileId: Annotated[
        str,
        Field(
            description='Compile Id for the project to backtest.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ]
    backtestName: Annotated[
        Optional[str],
        Field(
            description='Optional. Name for the new backtest.',
            examples=['New Backtest'],
        ),
    ] = None
    parameters_name_: Annotated[
        Optional[Dict[str, Any]],
        Field(
            alias='parameters[name]',
            description='Optional. Parameters used in the backtest.',
            examples=['parameters[ema_fast] = 10, parameters[ema_slow] = 100'],
        ),
    ] = None


class CreateLiveAlgorithmRequest(BaseModel):
    versionId: Annotated[
        Optional[str],
        Field(
            description='The version of the Lean used to run the algorithm. -1 is master, however, sometimes this can create problems with live deployments. If you experience problems using, try specifying the version of Lean you would like to use.',
            examples=['-1'],
        ),
    ] = None
    projectId: Annotated[int, Field(description='Project Id.', examples=[23456789])]
    compileId: Annotated[
        str,
        Field(
            description='Compile Id.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ]
    nodeId: Annotated[
        str, Field(description='Id of the node that will run the algorithm.')
    ]
    brokerage: Annotated[
        Dict[str, Any],
        Field(description='Brokerage configurations to be used in the live algorithm.'),
    ]
    dataProviders: Annotated[
        Dict[str, Any],
        Field(
            description='Dictionary of data provider configurations to be used in the live algorithm.'
        ),
    ]


class CreateLiveCommandRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Project for the live instance we want to run the command against.',
            examples=[23456789],
        ),
    ]
    command: Annotated[
        Dict[str, Any],
        Field(
            description='The command to run.',
            examples=[
                {
                    '$type': 'OrderCommand',
                    'symbol': {'id': 'BTCUSD 2XR', 'value': 'BTCUSD'},
                    'order_type': 'market',
                    'quantity': '0.1',
                    'limit_price': 0,
                    'stop_price': 0,
                    'tag': '',
                }
            ],
        ),
    ]


class BroadcastLiveCommandRequest(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description='Organization Id of the projects we would like to broadcast the command to',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    excludeProjectId: Annotated[
        Optional[int],
        Field(
            description='Project for the live instance we want to exclude from the broadcast list. If null, all projects will be included.',
            examples=[23456789],
        ),
    ] = None
    command: Annotated[
        Dict[str, Any],
        Field(
            description='The command to run.',
            examples=[
                {
                    '$type': 'OrderCommand',
                    'symbol': {'id': 'BTCUSD 2XR', 'value': 'BTCUSD'},
                    'order_type': 'market',
                    'quantity': '0.1',
                    'limit_price': 0,
                    'stop_price': 0,
                    'tag': '',
                }
            ],
        ),
    ]


class NodeType(Enum):
    O2_8 = 'O2-8'
    O4_12 = 'O4-12'
    O8_16 = 'O8-16'


class Status2(Enum):
    New = 'New'
    Aborted = 'Aborted'
    Running = 'Running'
    Completed = 'Completed'


class CreateProjectRequest(BaseModel):
    name: Annotated[str, Field(description='Project name.')]
    language: Annotated[Language, Field(description='Programming language to use.')]
    organizationId: Annotated[
        Optional[str],
        Field(
            description="The organization to create project under. If you don't provide a value, it defaults to your preferred organization.",
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ] = None


class CreateProjectFileRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Project Id to which the file belongs.', examples=[23456789]),
    ]
    name: Annotated[
        str, Field(description='The name of the new file.', examples=['main.py'])
    ]
    content: Annotated[
        str,
        Field(
            description='The content of the new file.',
            examples=['class CustomClass:\n    def __init__(self):\n        pass\n'],
        ),
    ]


class DeleteFileRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Project Id to which the file belongs.', examples=[23456789]),
    ]
    name: Annotated[
        str,
        Field(
            description='The name of the file that should be deleted.',
            examples=['file.py'],
        ),
    ]


class DeleteProjectRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Project Id to which the file belongs.', examples=[23456789]),
    ]


class DeleteBacktestRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Project Id for the backtest we want to delete.',
            examples=[23456789],
        ),
    ]
    backtestId: Annotated[
        str,
        Field(
            description='Backtest Id we want to delete.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ]


class DeleteObjectStoreRequest(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description="Organization ID we'd like to delete the Object Store file from.",
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    key: Annotated[
        str, Field(description='Key to the Object Store file', examples=['key1'])
    ]


class DeleteOptimizationRequest(BaseModel):
    optimizationId: Annotated[
        Optional[str],
        Field(
            description='Optimization ID we want to delete.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ] = None


class EncryptionKey(BaseModel):
    id: Annotated[Optional[str], Field(description='Encryption key id.')] = None
    name: Annotated[Optional[str], Field(description='Name of the encryption key.')] = (
        None
    )


class Estimate(BaseModel):
    estimateId: Annotated[Optional[str], Field(description='Estimate Id.')] = None
    time: Annotated[
        Optional[int], Field(description='Estimate time in seconds.', examples=[60])
    ] = None
    balance: Annotated[
        Optional[int], Field(description='Estimate balance in QCC.', examples=[10])
    ] = None


class EstimateOptimizationResponse(BaseModel):
    estimate: Optional[Estimate] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class GetObjectStoreJobIdRequest(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description='Organization ID we would like to get the Object Store files from.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    keys: Annotated[
        List[str],
        Field(
            description='Keys to the Object Store files.', examples=['["key1", "key2"]']
        ),
    ]


class GetObjectStoreURLRequest(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description='Organization ID we would like to get the Object Store files from.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    jobId: Annotated[
        str,
        Field(
            description='Job ID for getting a download URL for.', examples=['string']
        ),
    ]


class GetObjectStorePropertiesRequest(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description='Organization ID we would like to get the Object Store properties from.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    key: Annotated[
        str, Field(description='Key to the Object Store.', examples=['key1'])
    ]


class GetObjectStoreResponse(BaseModel):
    jobId: Annotated[
        Optional[str],
        Field(description='Job ID which can be used for querying state or packaging.'),
    ] = None
    url: Annotated[
        Optional[str],
        Field(description='The URL to download the object. This can also be null.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ObjectStoreProperties(BaseModel):
    key: Annotated[Optional[str], Field(description='Object Store key.')] = None
    modified: Annotated[
        Optional[date], Field(description='Last time it was modified.')
    ] = None
    created: Annotated[
        Optional[str], Field(description='Date this project was created.')
    ] = None
    size: Annotated[
        Optional[float], Field(description='Object Store file size.', examples=[24])
    ] = None
    md5: Annotated[
        Optional[str],
        Field(description='MD5 (hashing algorithm) hash authentication code.'),
    ] = None
    mime: Annotated[Optional[str], Field(description='MIME type.')] = None
    preview: Annotated[
        Optional[str], Field(description='Preview of the Object Store file content.')
    ] = None


class GridChart(BaseModel):
    chartName: Annotated[Optional[str], Field(description='The chart name.')] = None
    width: Annotated[Optional[int], Field(description='Width of the chart.')] = None
    height: Annotated[Optional[int], Field(description='Height of the chart.')] = None
    row: Annotated[Optional[int], Field(description='Number of rows of the chart.')] = (
        None
    )
    column: Annotated[
        Optional[int], Field(description='Number of columns of the chart.')
    ] = None
    sort: Annotated[Optional[int], Field(description='Sort of the chart.')] = None


class GroupOrderManager(BaseModel):
    id: Annotated[Optional[int], Field(description='The unique order group Id.')] = None
    quantity: Annotated[
        Optional[float], Field(description='The group order quantity.')
    ] = None
    count: Annotated[
        Optional[int],
        Field(description='The total order count associated with this order group.'),
    ] = None
    limitPrice: Annotated[
        Optional[float],
        Field(description='The limit price associated with this order group if any.'),
    ] = None
    orderIds: Annotated[
        Optional[List[int]], Field(description='The order Ids in this group.')
    ] = None
    direction: Annotated[
        Optional[int], Field(description='Order Direction Property based off Quantity.')
    ] = None


class Type(Enum):
    Base = 'Base'
    Equity = 'Equity'
    Option = 'Option'
    Commodity = 'Commodity'
    Forex = 'Forex'
    Future = 'Future'
    Cfd = 'Cfd'
    Crypto = 'Crypto'


class BrokerageHolding(BaseModel):
    symbolId: Annotated[
        Optional[str], Field(description='Symbol ID of the holding.')
    ] = None
    symbol: Annotated[
        Optional[str], Field(description='Symbol ticker of the holding.')
    ] = None
    quantity: Annotated[
        Optional[float], Field(description='Quantity of the Symbol we hold.')
    ] = None
    averagePrice: Annotated[
        Optional[float],
        Field(
            description='Average Price of our Holding in the currency the symbol is traded in.'
        ),
    ] = None


class IexPricePlan(Enum):
    Launch = 'Launch'
    Grow = 'Grow'
    Enterprise = 'Enterprise'


class IEXDataFeedSettings(BaseModel):
    id: Annotated[
        Optional[str], Field(description='Data provider ID, this is, IEXDataFeed.')
    ] = None
    iex_cloud_api_key: Annotated[
        Optional[str],
        Field(
            alias='iex-cloud-api-key',
            description='Your iexcloud.io API token publishable key.',
        ),
    ] = None
    iex_price_plan: Annotated[
        Optional[IexPricePlan],
        Field(alias='iex-price-plan', description='Your IEX Cloud Price plan.'),
    ] = None


class Type1(Enum):
    price = 'price'
    volatility = 'volatility'


class Direction(Enum):
    down = 'down'
    flat = 'flat'
    up = 'up'


class Insight(BaseModel):
    id: Annotated[Optional[str], Field(description='Insight ID.')] = None
    groupId: Annotated[
        Optional[str], Field(description='ID of the group of insights.')
    ] = None
    sourceModel: Annotated[
        Optional[str], Field(description='Name of the model that sourced the insight.')
    ] = None
    generatedTime: Annotated[
        Optional[str],
        Field(description='Gets the utc unixtime this insight was generated.'),
    ] = None
    createdTime: Annotated[
        Optional[float],
        Field(description='Gets the utc unixtime this insight was created.'),
    ] = None
    closeTime: Annotated[
        Optional[float],
        Field(description='Gets the utc unixtime this insight was closed.'),
    ] = None
    symbol: Annotated[
        Optional[str], Field(description='Gets the symbol ID this insight is for.')
    ] = None
    ticker: Annotated[
        Optional[str], Field(description='Gets the symbol ticker this insight is for.')
    ] = None
    type: Annotated[
        Optional[Type1],
        Field(
            description='Gets the type of insight, for example, price or volatility.'
        ),
    ] = None
    reference: Annotated[
        Optional[str],
        Field(
            description='Gets the initial reference value this insight is predicting against.'
        ),
    ] = None
    referenceValueFinal: Annotated[
        Optional[str],
        Field(
            description='Gets the final reference value, used for scoring, this insight is predicting against.'
        ),
    ] = None
    direction: Annotated[
        Optional[Direction],
        Field(description='Gets the predicted direction, down, flat or up.'),
    ] = None
    period: Annotated[
        Optional[float],
        Field(
            description='Gets the period, in seconds, over which this insight is expected to come to fruition.'
        ),
    ] = None
    magnitude: Annotated[
        Optional[float],
        Field(
            description='Gets the predicted percent change in the insight type (price/volatility). This value can be null.'
        ),
    ] = None
    confidence: Annotated[
        Optional[float],
        Field(
            description='Gets the confidence in this insight. This value can be null.'
        ),
    ] = None
    weight: Annotated[
        Optional[float],
        Field(
            description='Gets the portfolio weight of this insight. This value can be null.'
        ),
    ] = None
    scoreIsFinal: Annotated[
        Optional[bool],
        Field(description="Gets whether or not this is the insight's final score."),
    ] = None
    scoreDirection: Annotated[
        Optional[float], Field(description='Gets the direction score.')
    ] = None
    scoreMagnitude: Annotated[
        Optional[float], Field(description='Gets the magnitude score.')
    ] = None
    estimatedValue: Annotated[
        Optional[float],
        Field(
            description='Gets the estimated value of this insight in the account currency.'
        ),
    ] = None
    tag: Annotated[
        Optional[str],
        Field(description="The insight's tag containing additional information"),
    ] = None


class KrakenSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='ID of the brokerage, this is, KrakenBrokerage.'),
    ] = None
    kraken_api_key: Annotated[
        Optional[str], Field(alias='kraken-api-key', description='Your Kraken API key.')
    ] = None
    kraken_api_secret: Annotated[
        Optional[str],
        Field(alias='kraken-api-secret', description='Your Kraken API secret.'),
    ] = None
    kraken_verification_tier: Annotated[
        Optional[str],
        Field(
            alias='kraken-verification-tier',
            description='Your Kraken Verification Tier.',
        ),
    ] = None


class LeanVersion(BaseModel):
    id: Annotated[Optional[int], Field(description='ID of the LEAN version.')] = None
    created: Annotated[
        Optional[datetime], Field(description='Date when this version was created.')
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the LEAN version.')
    ] = None
    leanHash: Annotated[
        Optional[str], Field(description='Commit Hash in the LEAN repository.')
    ] = None
    leanCloudHash: Annotated[
        Optional[str], Field(description='Commit Hash in the LEAN Cloud repository.')
    ] = None
    name: Annotated[
        Optional[str], Field(description='Name of the branch where the commit is.')
    ] = None
    ref: Annotated[
        Optional[str], Field(description='Reference to the branch where the commit is.')
    ] = None
    public: Annotated[
        Optional[int],
        Field(
            description='Indicates if the version is available for the public (1) or not (0).'
        ),
    ] = None


class Library(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Project Id of the library project.', examples=[23456789]),
    ]
    libraryName: Annotated[
        Optional[str], Field(description='Name of the library project.')
    ] = None
    ownerName: Annotated[
        Optional[str], Field(description='Name of the library project owner.')
    ] = None
    access: Annotated[
        Optional[bool],
        Field(description='Indicate if the library project can be accessed.'),
    ] = None


class Status3(Enum):
    DeployError = 'DeployError'
    InQueue = 'InQueue'
    Running = 'Running'
    Stopped = 'Stopped'
    Liquidated = 'Liquidated'
    Deleted = 'Deleted'
    Completed = 'Completed'
    RuntimeError = 'RuntimeError'
    Invalid = 'Invalid'
    LoggingIn = 'LoggingIn'
    Initializing = 'Initializing'
    History = 'History'


class Brokerage(Enum):
    Interactive = 'Interactive'
    FXCM = 'FXCM'
    Oanda = 'Oanda'
    Tradier = 'Tradier'
    PaperBrokerage = 'PaperBrokerage'
    Alpaca = 'Alpaca'
    Bitfinex = 'Bitfinex'
    Binance = 'Binance'
    Coinbase = 'Coinbase'


class LiveAlgorithm(BaseModel):
    projectId: Annotated[
        int, Field(description='Project Id for the live instance.', examples=[23456789])
    ]
    deployId: Annotated[
        Optional[str],
        Field(
            description='Unique live algorithm deployment identifier (similar to a backtest id).',
            examples=['L-sdf86b7045bb83203e79d2aa6150b321'],
        ),
    ] = None
    status: Annotated[
        Optional[Status3], Field(description='States of a live deployment.')
    ] = None
    launched: Annotated[
        Optional[datetime],
        Field(description='Datetime the algorithm was launched in UTC.'),
    ] = None
    stopped: Annotated[
        Optional[datetime],
        Field(
            description='Datetime the algorithm was stopped in UTC, null if its still running.'
        ),
    ] = None
    brokerage: Annotated[Optional[Brokerage], Field(description='Brokerage')] = None
    subscription: Annotated[
        Optional[str], Field(description="Chart we're subscribed to.")
    ] = None
    error: Annotated[
        Optional[str],
        Field(
            description='Live algorithm error message from a crash or algorithm runtime error.'
        ),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class LiveAuthenticationData(BaseModel):
    pass


class NotifyInsights(Enum):
    true = 'true'
    false = 'false'


class NotifyOrderEvents(Enum):
    true = 'true'
    false = 'false'


class AutoRestart(Enum):
    true = 'true'
    false = 'false'


class LiveAlgorithmListResponse(BaseModel):
    live: Annotated[
        Optional[List[LiveAlgorithm]],
        Field(description='Algorithm list matching the requested status.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class LiquidateLiveAlgorithmRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Project Id for the live instance we want to liquidate.',
            examples=[23456789],
        ),
    ]


class ListObjectStoreRequest(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description="Organization ID we'd like to list the Object Store files from.",
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    path: Annotated[
        Optional[str],
        Field(
            description='Optional. Path to the Object Store files.',
            examples=['/folder1'],
        ),
    ] = None


class ListOptimizationRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description="Project ID we'd like to get a list of optimizations for.",
            examples=[23456789],
        ),
    ]


class LiveInsightsResponse(BaseModel):
    insights: Annotated[
        Optional[List[Insight]], Field(description='Collection of insights.')
    ] = None
    length: Annotated[
        Optional[int], Field(description='Total number of returned insights')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class LoadingChartResponse(BaseModel):
    progress: Annotated[
        Optional[float],
        Field(description='Loading percentage of the chart generation process.'),
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description='Status of the chart generation process.', examples=['loading']
        ),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class Market(Enum):
    usa = 'usa'
    oanda = 'oanda'
    fxcm = 'fxcm'
    dukascopy = 'dukascopy'
    bitfinex = 'bitfinex'
    cmeglobex = 'cmeglobex'
    nymex = 'nymex'
    cbot = 'cbot'
    ice = 'ice'
    cboe = 'cboe'
    nse = 'nse'
    comex = 'comex'
    cme = 'cme'
    sgx = 'sgx'
    hkfe = 'hkfe'
    coinbase = 'coinbase'
    kraken = 'kraken'
    bitstamp = 'bitstamp'
    okcoin = 'okcoin'
    bithumb = 'bithumb'
    binance = 'binance'
    poloniex = 'poloniex'
    coinone = 'coinone'
    hitbtc = 'hitbtc'
    bittrex = 'bittrex'


class OandaEnvironment(Enum):
    Practice = 'Practice'
    Trade = 'Trade'


class OandaSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='ID of the brokerage, this is, OandaBrokerage.'),
    ] = None
    oanda_account_id: Annotated[
        Optional[str],
        Field(
            alias='oanda-account-id',
            description="Your OANDA account id can be found on your OANDA Account Statement page (https://www.oanda.com/account/statement/). It follows the following format '###-###-######-###'.",
        ),
    ] = None
    oanda_access_token: Annotated[
        Optional[str],
        Field(
            alias='oanda-access-token',
            description='Your OANDA API token. You can generate an API token from the Manage API Access page (https://www.oanda.com/account/tpa/personal_token).',
        ),
    ] = None
    oanda_environment: Annotated[
        Optional[OandaEnvironment],
        Field(
            alias='oanda-environment',
            description='The environment to run in, Practice for fxTrade Practice, Trade for fxTrade.',
        ),
    ] = None


class ObjectStoreBinaryFile(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description='Orgainization ID.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    key: Annotated[
        str,
        Field(
            description='Unique key to access the object in Object Store.',
            examples=['key1'],
        ),
    ]
    objectData: Annotated[bytes, Field(description='Object data to be stored.')]


class ObjectStoreSummary(BaseModel):
    key: Annotated[
        Optional[str], Field(description='Object Store key.', examples=['Mia/Test'])
    ] = None
    name: Annotated[Optional[str], Field(description='File or folder name.')] = None
    modified: Annotated[
        Optional[datetime], Field(description='Last time it was modified.')
    ] = None
    mime: Annotated[
        Optional[str], Field(description='MIME type.', examples=['application/json'])
    ] = None
    folder: Annotated[
        Optional[bool], Field(description='True if it is a folder, false otherwise.')
    ] = None
    size: Annotated[
        Optional[float], Field(description='Object Store file size.', examples=[13])
    ] = None


class OptimizationConstraint(BaseModel):
    target: Annotated[
        Optional[str],
        Field(
            description='Property we want to track',
            examples=['TotalPerformance.PortfolioStatistics.SharpeRatio'],
        ),
    ] = None
    operator: Annotated[
        Optional[str],
        Field(description='The target comparison operation', examples=['greater']),
    ] = None
    targetValue: Annotated[
        Optional[float],
        Field(description='The value of the property we want to track', examples=[1]),
    ] = None


class OptimizationParameter(BaseModel):
    name: Annotated[
        Optional[str],
        Field(description='Name of optimization parameter.', examples=['rsi_period']),
    ] = None
    min: Annotated[
        Optional[float],
        Field(
            description='Minimum value of optimization parameter, applicable for boundary conditions.',
            examples=[10],
        ),
    ] = None
    max: Annotated[
        Optional[float],
        Field(
            description='Maximum value of optimization parameter, applicable for boundary conditions.',
            examples=[20],
        ),
    ] = None
    step: Annotated[
        Optional[float], Field(description='Movement, should be positive', examples=[1])
    ] = None
    minStep: Annotated[
        Optional[float],
        Field(
            description='Minimal possible movement for current parameter, should be positive. Used by <code>Strategies.EulerSearchOptimizationStrategy</code> to determine when this parameter can no longer be optimized.',
            examples=[1],
        ),
    ] = None


class OptimizationTarget(BaseModel):
    target: Annotated[
        Optional[str],
        Field(
            description='Property we want to track',
            examples=['TotalPerformance.PortfolioStatistics.SharpeRatio'],
        ),
    ] = None
    extremum: Annotated[
        Optional[str],
        Field(
            description='Defines the direction of optimization.',
            examples=['max or min'],
        ),
    ] = None
    targetValue: Annotated[
        Optional[float],
        Field(description='The value of the property we want to track', examples=[1]),
    ] = None


class NodePrices(BaseModel):
    monthly: Annotated[
        Optional[int], Field(description='The monthly price of the node in US dollars.')
    ] = None
    yearly: Annotated[
        Optional[int], Field(description='The yearly price of the node in US dollars.')
    ] = None


class NodeType2(Enum):
    Backtest = 'Backtest'
    Research = 'Research'
    Live = 'Live'


class Status4(Enum):
    New = 'New'
    Aborted = 'Aborted'
    Running = 'Running'
    Completed = 'Completed'


class NodeType3(Enum):
    O2_8 = 'O2-8'
    O4_12 = 'O4-12'
    O8_16 = 'O8-16'


class Backtests(BaseModel):
    pass


class OptimizationBacktest(BaseModel):
    name: Annotated[Optional[str], Field(description='The backtest name.')] = None
    id: Annotated[Optional[str], Field(description='The backtest id')] = None
    progress: Annotated[
        Optional[str],
        Field(
            description='Progress of the backtest as a percentage from 0-1 based on the days lapsed from start-finish.'
        ),
    ] = None
    exitCode: Annotated[
        Optional[int], Field(description='The exit code of this backtest')
    ] = None
    statistics: Annotated[
        Optional[List[float]], Field(description='The backtest statistics results.')
    ] = None
    parameterSet: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description="Dictionary representing a combination as key value of parameters, i.e. order doesn't matter."
        ),
    ] = None
    equity: Annotated[
        Optional[List[int]], Field(description='The backtest equity chart series.')
    ] = None
    startDate: Annotated[
        Optional[datetime], Field(description='The backtest start date.')
    ] = None
    endDate: Annotated[
        Optional[datetime], Field(description='The backtest end date.')
    ] = None
    outOfSampleDays: Annotated[
        Optional[int], Field(description='The backtest out of sample day count.')
    ] = None
    outOfSampleMaxEndDate: Annotated[
        Optional[str], Field(description='Backtest maximum end date.')
    ] = None


class Type2(Enum):
    field_0___Market = '0 = Market'
    field_1___Limit = '1 = Limit'
    field_2___StopMarket = '2 = StopMarket'
    field_3___StopLimit = '3 = StopLimit'
    field_4___MarketOnOpen = '4 = MarketOnOpen'
    field_5___MarketOnClose = '5 = MarketOnClose'
    field_6___OptionExercise = '6 = OptionExercise'
    field_7___LimitIfTouched = '7 = LimitIfTouched'
    field_8___ComboMarket = '8 = ComboMarket'
    field_9___ComboLimit = '9 = ComboLimit'
    field_10___ComboLegLimit = '10 = ComboLegLimit'
    field_11___TrailingStop = '11 = TrailingStop'


class Status5(Enum):
    field_0___New = '0 = New'
    field_1___Submitted = '1 = Submitted'
    field_2___PartiallyFilled = '2 = PartiallyFilled'
    field_3___Filled = '3 = Filled'
    field_5___Canceled = '5 = Canceled'
    field_6___None = '6 = None'
    field_7___Invalid = '7 = Invalid'
    field_8___CancelPending = '8 = CancelPending'
    field_9___UpdateSubmitted = '9 = UpdateSubmitted'


class SecurityType(Enum):
    field_0___Base = '0 = Base'
    field_1___Equity = '1 = Equity'
    field_2___Option = '2 = Option'
    field_3___Commodity = '3 = Commodity'
    field_4___Forex = '4 = Forex'
    field_5___Future = '5 = Future'
    field_6___Cfd = '6 = Cfd'
    field_7___Crypto = '7 = Crypto'


class Direction1(Enum):
    field_0___Buy = '0 = Buy'
    field_1___Sell = '1 = Sell'
    field_2___Hold = '2 = Hold'


class OrderProperties(BaseModel):
    timeInForce: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Defines the length of time over which an order will continue working before it is cancelled.'
        ),
    ] = None


class OrderDirection(Enum):
    buy = 'buy'
    sell = 'sell'
    hold = 'hold'


class Status6(Enum):
    new = 'new'
    submitted = 'submitted'
    partiallyFilled = 'partiallyFilled'
    filled = 'filled'
    canceled = 'canceled'
    none = 'none'
    invalid = 'invalid'
    cancelPending = 'cancelPending'
    updateSubmitted = 'updateSubmitted'


class OrderEvent(BaseModel):
    algorithmId: Annotated[
        Optional[str], Field(description='Algorithm Id, BacktestId or DeployId.')
    ] = None
    symbol: Annotated[
        Optional[str],
        Field(
            description='Easy access to the order symbol associated with this event.'
        ),
    ] = None
    symbolValue: Annotated[
        Optional[str],
        Field(
            description='The current symbol for this ticker; It is a user friendly symbol representation.'
        ),
    ] = None
    symbolPermtick: Annotated[
        Optional[str],
        Field(description='The original symbol used to generate this symbol.'),
    ] = None
    orderId: Annotated[
        Optional[int], Field(description='Id of the order this event comes from.')
    ] = None
    orderEventId: Annotated[
        Optional[int], Field(description='The unique order event id for each order.')
    ] = None
    id: Annotated[
        Optional[int], Field(description='The unique order event Id for each order.')
    ] = None
    status: Annotated[Optional[Status6], Field(description='Status of the Order.')] = (
        None
    )
    orderFeeAmount: Annotated[
        Optional[float], Field(description='The fee amount associated with the order.')
    ] = None
    orderFeeCurrency: Annotated[
        Optional[str], Field(description='The fee currency associated with the order.')
    ] = None
    fillPrice: Annotated[
        Optional[float], Field(description='Fill price information about the order.')
    ] = None
    fillPriceCurrency: Annotated[
        Optional[str], Field(description='Currency for the fill price.')
    ] = None
    fillQuantity: Annotated[
        Optional[float],
        Field(
            description='Number of shares of the order that was filled in this event.'
        ),
    ] = None
    direction: Annotated[
        Optional[OrderDirection], Field(description='Order direction.')
    ] = None
    message: Annotated[
        Optional[str], Field(description='Any message from the exchange.')
    ] = None
    isAssignment: Annotated[
        Optional[bool], Field(description='True if the order event is an assignment.')
    ] = None
    stopPrice: Annotated[
        Optional[float], Field(description='The current stop price.')
    ] = None
    limitPrice: Annotated[
        Optional[float], Field(description='The current limit price.')
    ] = None
    quantity: Annotated[
        Optional[float], Field(description='The current order quantity.')
    ] = None
    time: Annotated[
        Optional[int], Field(description='The time of this event in unix timestamp.')
    ] = None
    isInTheMoney: Annotated[
        Optional[bool],
        Field(description="True if the order event's option is In-The-Money (ITM)."),
    ] = None


class OrderSubmissionData(BaseModel):
    bidPrice: Annotated[
        Optional[float], Field(description='The bid price at an order submission time.')
    ] = None
    askPrice: Annotated[
        Optional[float], Field(description='The ask price at an order submission time.')
    ] = None
    lastPrice: Annotated[
        Optional[float],
        Field(description='The current price at an order submission time.'),
    ] = None


class ParameterSet(BaseModel):
    name: Annotated[Optional[str], Field(description='Name of parameter.')] = None
    value: Annotated[
        Optional[Union[int, float, str]], Field(description='Value of parameter.')
    ] = None


class PolygonSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='ID of the brokerage, this is, PolygonDataFeed.'),
    ] = None
    polygon_api_key: Annotated[
        Optional[str],
        Field(alias='polygon-api-key', description='Your Polygon.io API Key.'),
    ] = None


class Portfolio(BaseModel):
    holdings: Annotated[
        Optional[Dict[str, Any]],
        Field(description='Dictionary of algorithm holdings information.'),
    ] = None
    cash: Annotated[
        Optional[Dict[str, Any]],
        Field(description='Dictionary of algorithm cash currencies information.'),
    ] = None


class ProjectFile(BaseModel):
    id: Annotated[
        Optional[int],
        Field(description='ID of the project file. This can also be null.'),
    ] = None
    projectId: Annotated[
        int, Field(description='ID of the project.', examples=[23456789])
    ]
    name: Annotated[Optional[str], Field(description='Name of a project file.')] = None
    content: Annotated[
        Optional[str], Field(description='Contents of the project file.')
    ] = None
    modified: Annotated[
        Optional[datetime], Field(description='DateTime project file was modified.')
    ] = None
    open: Annotated[
        Optional[bool],
        Field(description='Indicates if the project file is open or not.'),
    ] = None
    isLibrary: Annotated[
        Optional[bool],
        Field(
            description="Indicates if the project file is a library or not. It's always false in live/read and backtest/read."
        ),
    ] = None


class ProjectFilesResponse(BaseModel):
    files: Annotated[
        Optional[List[ProjectFile]],
        Field(description='List of project file information.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class File(BaseModel):
    name: Annotated[Optional[str], Field(description='Name of a file.')] = None
    content: Annotated[Optional[str], Field(description='Contents of the file.')] = None


class Error(BaseModel):
    message: Annotated[Optional[str], Field(description='Error message.')] = None
    stacktrace: Annotated[
        Optional[str], Field(description='Stack trace of the error.')
    ] = None


class PortfolioStatistics(BaseModel):
    averageWinRate: Annotated[
        Optional[float],
        Field(description='The average rate of return for winning trades.'),
    ] = None
    averageLossRate: Annotated[
        Optional[float],
        Field(description='The average rate of return for losing trades.'),
    ] = None
    profitLossRatio: Annotated[
        Optional[float],
        Field(
            description='The ratio of the average win rate to the average loss rate.'
        ),
    ] = None
    winRate: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of winning trades to the total number of trades.'
        ),
    ] = None
    lossRate: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of losing trades to the total number of trades.'
        ),
    ] = None
    expectancy: Annotated[
        Optional[float], Field(description='The expected value of the rate of return.')
    ] = None
    startEquity: Annotated[
        Optional[float], Field(description='Initial Equity Total Value.')
    ] = None
    endEquity: Annotated[
        Optional[float], Field(description='Final Equity Total Value')
    ] = None
    compoundingAnnualReturn: Annotated[
        Optional[float],
        Field(
            description='Annual compounded returns statistic based on the final-starting capital and years.'
        ),
    ] = None
    drawdown: Annotated[
        Optional[float], Field(description='Drawdown maximum percentage.')
    ] = None
    totalNetProfit: Annotated[
        Optional[float], Field(description='The total net profit percentage.')
    ] = None
    sharpeRatio: Annotated[
        Optional[float],
        Field(
            description='Sharpe ratio with respect to risk free rate: measures excess of return per unit of risk.'
        ),
    ] = None
    probabilisticSharpeRatio: Annotated[
        Optional[float],
        Field(
            description='Probabilistic Sharpe Ratio is a probability measure associated with the Sharpe ratio. It informs us of the probability that the estimated Sharpe ratio is greater than a chosen benchmark.'
        ),
    ] = None
    sortinoRatio: Annotated[
        Optional[float],
        Field(
            description='Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.'
        ),
    ] = None
    alpha: Annotated[
        Optional[float],
        Field(
            description='Algorithm "Alpha" statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns.'
        ),
    ] = None
    beta: Annotated[
        Optional[float],
        Field(
            description='Algorithm beta statistic - the covariance between the algorithm and benchmark performance, divided by benchmark variance.'
        ),
    ] = None
    annualStandardDeviation: Annotated[
        Optional[float], Field(description='Annualized standard deviation')
    ] = None
    annualVariance: Annotated[
        Optional[float],
        Field(
            description='Annualized variance statistic calculation using the daily performance variance and trading days per year.'
        ),
    ] = None
    informationRatio: Annotated[
        Optional[float], Field(description='Information ratio - risk adjusted return.')
    ] = None
    trackingError: Annotated[
        Optional[float],
        Field(
            description='Tracking error volatility (TEV) statistic - a measure of how closely a portfolio follows the index to which it is benchmarked.'
        ),
    ] = None
    treynorRatio: Annotated[
        Optional[float],
        Field(
            description='Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.'
        ),
    ] = None
    portfolioTurnover: Annotated[
        Optional[float], Field(description='The average Portfolio Turnover.')
    ] = None
    valueAtRisk99: Annotated[
        Optional[float],
        Field(
            description='The 1-day VaR for the portfolio, using the Variance-covariance approach. Assumes a 99% confidence level, 1 year lookback period, and that the returns are normally distributed.'
        ),
    ] = None
    valueAtRisk95: Annotated[
        Optional[float],
        Field(
            description='The 1-day VaR for the portfolio, using the Variance-covariance approach. Assumes a 95% confidence level, 1 year lookback period, and that the returns are normally distributed.'
        ),
    ] = None


class RBIBrokerageSettings(BaseModel):
    id: Annotated[
        Optional[str], Field(description='Brokerage ID, this is, RBIBrokerage.')
    ] = None
    rbi_on_behalf_of_comp_id: Annotated[
        Optional[str],
        Field(
            alias='rbi-on-behalf-of-comp-id',
            description='Value used to identify the trading firm.',
        ),
    ] = None
    rbi_account: Annotated[
        Optional[str], Field(alias='rbi-account', description='RBI account name.')
    ] = None
    cash: Annotated[
        Optional[List[CashAmount]], Field(description='List of cash amount.')
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class ReadFilesRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Project Id to which the file belongs.', examples=[23456789]),
    ]
    name: Annotated[
        Optional[str],
        Field(
            description='Optional. The name of the file that will be read.',
            examples=['file.py'],
        ),
    ] = None


class ReadCompileRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project you requested to compile.',
            examples=[23456789],
        ),
    ]
    compileId: Annotated[
        str,
        Field(
            description='Compile Id returned during the creation request.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ]


class ReadLiveLogsRequest(BaseModel):
    format: Annotated[
        Optional[Any], Field(description='Format of the log results', examples=['json'])
    ] = None
    projectId: Annotated[
        int,
        Field(
            description='Project Id of the live running algorithm.', examples=[23456789]
        ),
    ]
    algorithmId: Annotated[
        str,
        Field(description='Deploy Id (Algorithm Id) of the live running algorithm.'),
    ]
    startLine: Annotated[int, Field(description='Start line of logs to read.')]
    endLine: Annotated[int, Field(description='End line of logs to read.')]


class ReadLiveLogsResponse(BaseModel):
    logs: Annotated[
        Optional[List[str]], Field(description='List of logs from the live algorithm.')
    ] = None
    length: Annotated[
        Optional[int], Field(description='Total amount of rows in the logs.')
    ] = None
    deploymentOffset: Annotated[
        Optional[int],
        Field(description='Amount of log rows before the current deployment.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ReadProjectRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project. If not provided the API will return a details list of all projects.',
            examples=[23456789],
        ),
    ]


class ReadProjectNodesRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project to which the nodes refer.',
            examples=[23456789],
        ),
    ]


class ReadLiveAlgorithmRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Id of the project to read.', examples=[23456789])
    ]
    deployId: Annotated[
        Optional[str],
        Field(
            description='Specific instance Id to read.',
            examples=['L-sdf86b7045bb83203e79d2aa6150b321'],
        ),
    ] = None


class ReadLivePortfolioRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read the live algorithm.',
            examples=[23456789],
        ),
    ]


class ReadLiveOrdersRequest(BaseModel):
    start: Annotated[
        Optional[int],
        Field(
            description='Starting index of the orders to be fetched. Required if end > 100.',
            examples=[0],
        ),
    ] = None
    end: Annotated[
        int,
        Field(
            description='Last index of the orders to be fetched. Note that end - start must be less than 100.',
            examples=[100],
        ),
    ]
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read the live algorithm.',
            examples=[23456789],
        ),
    ]


class ReadLiveInsightsRequest(BaseModel):
    start: Annotated[
        Optional[int],
        Field(
            description='Starting index of the insights to be fetched. Required if end > 100.',
            examples=[0],
        ),
    ] = None
    end: Annotated[
        int,
        Field(
            description='Last index of the insights to be fetched. Note that end - start must be less than 100.',
            examples=[100],
        ),
    ]
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read the live algorithm.',
            examples=[23456789],
        ),
    ]


class Status7(Enum):
    DeployError = 'DeployError'
    InQueue = 'InQueue'
    Running = 'Running'
    Stopped = 'Stopped'
    Liquidated = 'Liquidated'
    Deleted = 'Deleted'
    Completed = 'Completed'
    RuntimeError = 'RuntimeError'
    Invalid = 'Invalid'
    LoggingIn = 'LoggingIn'
    Initializing = 'Initializing'
    History = 'History'


class ListLiveAlgorithmsRequest(BaseModel):
    status: Annotated[
        Optional[Status7], Field(description='States of a live deployment.')
    ] = None
    start: Annotated[
        Optional[float],
        Field(
            description='Earliest launched time of the algorithms in UNIX timestamp.',
            examples=[1717801200],
        ),
    ] = None
    end: Annotated[
        Optional[float],
        Field(
            description='Latest launched time of the algorithms in UNIX timestamp.',
            examples=[171851200],
        ),
    ] = None


class ReadBacktestRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read one or multiple backtests.',
            examples=[23456789],
        ),
    ]
    backtestId: Annotated[
        str,
        Field(
            description='When provided, specific backtest Id to read.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ]
    chart: Annotated[
        Optional[str],
        Field(
            description='Optional. If provided, the API will return the backtests charts.',
            examples=['Strategy Equity'],
        ),
    ] = None


class ListBacktestRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read one or multiple backtests.',
            examples=[23456789],
        ),
    ]
    includeStatistics: Annotated[
        Optional[bool],
        Field(
            description='If true, the backtests summaries from the response will contain the statistics with their corresponding values.',
            examples=[True],
        ),
    ] = None


class QuantConnectSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='ID of QuantConnect, this is QuantConnectBrokerage.'),
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None
    cash: Annotated[
        Optional[List[CashAmount]], Field(description='List of cash amount.')
    ] = None


class IbTradingMode(Enum):
    live = 'live'
    paper = 'paper'


class InteractiveBrokersSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(
            description='ID of InteractiveBrokers, this is InteractiveBrokersBrokerage.'
        ),
    ] = None
    ib_user_name: Annotated[
        Optional[str],
        Field(alias='ib-user-name', description='Your Interactive Brokers username.'),
    ] = None
    ib_password: Annotated[
        Optional[str],
        Field(alias='ib-password', description='Your Interactive Brokers password.'),
    ] = None
    ib_trading_mode: Annotated[
        Optional[IbTradingMode],
        Field(
            alias='ib-trading-mode',
            description='Represents the types of environments supported by Interactive Brokers for trading.',
        ),
    ] = None
    ib_account: Annotated[
        Optional[str],
        Field(alias='ib-account', description='Your Interactive Brokers account id.'),
    ] = None
    ib_weekly_restart_utc_time: Annotated[
        Optional[date],
        Field(
            alias='ib-weekly-restart-utc-time',
            description='Weekly restart UTC time (hh:mm:ss).',
        ),
    ] = None


class ReadBacktestChartRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Project ID of the request.', examples=[12345678])
    ]
    backtestId: Annotated[
        str,
        Field(
            description='Associated Backtest ID for this chart request.',
            examples=['2a748c241eb93b0b57b4747b3dacc80e'],
        ),
    ]
    name: Annotated[
        str,
        Field(description='The requested chart name.', examples=['Strategy Equity']),
    ]
    count: Annotated[
        int, Field(description='The number of data points to request.', examples=[100])
    ]
    start: Annotated[
        int,
        Field(
            description='Optional. If provided, the Utc start seconds timestamp of the request.',
            examples=[1717801200],
        ),
    ]
    end: Annotated[
        int,
        Field(
            description='Optional. If provided, the Utc end seconds timestamp of the request.',
            examples=[1743462000],
        ),
    ]


class ReadBacktestOrdersRequest(BaseModel):
    start: Annotated[
        int,
        Field(
            description='Starting index of the orders to be fetched. Required if end > 100.',
            examples=[0],
        ),
    ]
    end: Annotated[
        int,
        Field(
            description='Last index of the orders to be fetched. Note that end - start must be less than 100.',
            examples=[100],
        ),
    ]
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read the backtest.',
            examples=[23456789],
        ),
    ]
    backtestId: Annotated[
        str,
        Field(
            description='Id of the backtest from which to read the orders.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ]


class ReadBacktestInsightsRequest(BaseModel):
    start: Annotated[
        int,
        Field(
            description='Starting index of the insights to be fetched. Required if end > 100.',
            examples=[0],
        ),
    ]
    end: Annotated[
        int,
        Field(
            description='Last index of the insights to be fetched. Note that end - start must be less than 100.',
            examples=[100],
        ),
    ]
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read the backtest.',
            examples=[23456789],
        ),
    ]
    backtestId: Annotated[
        str,
        Field(
            description='Id of the backtest from which to read the insights.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ]


class ReadLiveChartRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Project ID of the request.', examples=[23456789])
    ]
    name: Annotated[
        str,
        Field(description='The requested chart name.', examples=['Strategy Equity']),
    ]
    count: Annotated[
        int, Field(description='The number of data points to request.', examples=[100])
    ]
    start: Annotated[
        int,
        Field(
            description='The Utc start seconds timestamp of the request.',
            examples=[1717801200],
        ),
    ]
    end: Annotated[
        int,
        Field(
            description='The Utc end seconds timestamp of the request.',
            examples=[1743462000],
        ),
    ]


class ReadOptimizationRequest(BaseModel):
    optimizationId: Annotated[
        str,
        Field(
            description='Optimization ID for the optimization we want to read.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ]


class RequestFailedError(BaseModel):
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ResearchGuide(BaseModel):
    minutes: Annotated[
        Optional[int],
        Field(description='Number of minutes used in developing the current backtest.'),
    ] = None
    backtestCount: Annotated[
        Optional[int],
        Field(description='The quantity of backtests run in the project.'),
    ] = None
    parameters: Annotated[
        Optional[int], Field(description='Number of parameters detected.')
    ] = None


class RestResponse(BaseModel):
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class Resolution(Enum):
    Tick = 'Tick'
    Second = 'Second'
    Minute = 'Minute'
    Hour = 'Hour'
    Daily = 'Daily'


class RuntimeStatistics(BaseModel):
    Equity: Annotated[
        Optional[str], Field(description='Total portfolio value.', examples=['$100.00'])
    ] = None
    Fees: Annotated[
        Optional[str], Field(description='Transaction fee.', examples=['-$100.00'])
    ] = None
    Holdings: Annotated[
        Optional[str],
        Field(description='Equity value of security holdings.', examples=['$100.00']),
    ] = None
    Net_Profit: Annotated[
        Optional[str],
        Field(alias='Net Profit', description='Net profit.', examples=['$100.00']),
    ] = None
    Probabilistic_Sharpe_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Probabilistic Sharpe Ratio',
            description='Probabilistic Sharpe Ratio.',
            examples=['50.00%'],
        ),
    ] = None
    Return: Annotated[
        Optional[str], Field(description='Return.', examples=['50.00%'])
    ] = None
    Unrealized: Annotated[
        Optional[str],
        Field(description='Unrealized profit/loss.', examples=['$100.00']),
    ] = None
    Volume: Annotated[
        Optional[str],
        Field(description='Total transaction volume.', examples=['$100.00']),
    ] = None


class ChartResolution(Enum):
    field_10minute = '10minute'
    minute = 'minute'
    second = 'second'


class SamcoProductType(Enum):
    mis = 'mis'
    cnc = 'cnc'
    nrml = 'nrml'


class SamcoTradingSegment(Enum):
    equity = 'equity'
    commodity = 'commodity'


class SamcoSettings(BaseModel):
    id: Annotated[
        Optional[str], Field(description='Brokerage ID, this is, SamcoBrokerage.')
    ] = None
    samco_client_id: Annotated[
        Optional[str],
        Field(alias='samco-client-id', description='Your Samco account Client ID.'),
    ] = None
    samco_client_password: Annotated[
        Optional[str],
        Field(
            alias='samco-client-password', description='Your Samco account password.'
        ),
    ] = None
    samco_year_of_birth: Annotated[
        Optional[int],
        Field(
            alias='samco-year-of-birth',
            description='Your year of birth (YYYY) registered with Samco.',
        ),
    ] = None
    samco_product_type: Annotated[
        Optional[SamcoProductType],
        Field(
            alias='samco-product-type',
            description='MIS if you are targeting intraday products, CNC if you are targeting delivery products, NRML if you are targeting carry forward products.',
        ),
    ] = None
    samco_trading_segment: Annotated[
        Optional[SamcoTradingSegment],
        Field(
            alias='samco-trading-segment',
            description="\\'equity\\' if you are trading equities on NSE or BSE, commodity if you are trading \\'commodities\\' on MCX.",
        ),
    ] = None


class SeriesType(Enum):
    Line = 'Line'
    Scatter = 'Scatter'
    Candle = 'Candle'
    Bar = 'Bar'
    Flag = 'Flag'
    StackedArea = 'StackedArea'
    Pie = 'Pie'
    Treemap = 'Treemap'


class ScatterMarkerSymbol(Enum):
    none = 'none'
    circle = 'circle'
    square = 'square'
    diamond = 'diamond'
    triangle = 'triangle'
    triangle_down = 'triangle-down'


class Series(BaseModel):
    name: Annotated[Optional[str], Field(description='Name of the series.')] = None
    unit: Annotated[Optional[str], Field(description='Axis for the chart series.')] = (
        None
    )
    index: Annotated[
        Optional[int], Field(description='Index/position of the series on the chart.')
    ] = None
    values: Annotated[
        Optional[List[Dict[str, Any]]],
        Field(
            description='Values for the series plot. These values are assumed to be in ascending time order (first points earliest, last points latest)'
        ),
    ] = None
    seriesType: Annotated[
        Optional[SeriesType], Field(description='Chart type for the series.')
    ] = None
    color: Annotated[Optional[str], Field(description='Color the series.')] = None
    scatterMarkerSymbol: Annotated[
        Optional[ScatterMarkerSymbol],
        Field(description='Shape or symbol for the marker in a scatter plot.'),
    ] = None


class SetObjectStoreRequest(BaseModel):
    organizationId: Annotated[
        Optional[str],
        Field(
            description="Organization ID we'd like to upload the file to.",
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ] = None
    key: Annotated[
        Optional[str], Field(description='Key to the Object Store file.')
    ] = None


class StatisticsResult(BaseModel):
    Total_Orders: Annotated[
        Optional[str], Field(alias='Total Orders', description='Total nuber of orders.')
    ] = None
    Average_Win: Annotated[
        Optional[str],
        Field(
            alias='Average Win',
            description='The average rate of return for winning trades.',
        ),
    ] = None
    Average_Loss: Annotated[
        Optional[str],
        Field(
            alias='Average Loss',
            description='The average rate of return for losing trades.',
        ),
    ] = None
    Compounding_Annual_Return: Annotated[
        Optional[str],
        Field(
            alias='Compounding Annual Return',
            description='Annual compounded returns statistic based on the final-starting capital and years.',
        ),
    ] = None
    Drawdown: Annotated[
        Optional[str], Field(description='Drawdown maximum percentage.')
    ] = None
    Expectancy: Annotated[
        Optional[str], Field(description='The expected value of the rate of return.')
    ] = None
    Start_Equity: Annotated[
        Optional[str],
        Field(alias='Start Equity', description='Initial Equity Total Value.'),
    ] = None
    End_Equity: Annotated[
        Optional[str],
        Field(alias='End Equity', description='Final Equity Total Value.'),
    ] = None
    Net_Profit: Annotated[
        Optional[str],
        Field(alias='Net Profit', description='The total net profit percentage.'),
    ] = None
    Sharpe_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Sharpe Ratio',
            description='Sharpe ratio with respect to risk free rate; measures excess of return per unit of risk.',
        ),
    ] = None
    Sortino_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Sortino Ratio',
            description='Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.',
        ),
    ] = None
    Probabilistic_Sharpe_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Probabilistic Sharpe Ratio',
            description='Is a probability measure associated with the Sharpe ratio. It informs us of the probability that the estimated Sharpe ratio is greater than a chosen benchmark.',
        ),
    ] = None
    Loss_Rate: Annotated[
        Optional[str],
        Field(
            alias='Loss Rate',
            description='The ratio of the number of losing trades to the total number of trades.',
        ),
    ] = None
    Win_Rate: Annotated[
        Optional[str],
        Field(
            alias='Win Rate',
            description='The ratio of the number of winning trades to the total number of trades.',
        ),
    ] = None
    Profit_Loss_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Profit-Loss Ratio',
            description='The ratio of the average win rate to the average loss rate.',
        ),
    ] = None
    Alpha: Annotated[
        Optional[str],
        Field(
            description='Algorithm "Alpha" statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns.'
        ),
    ] = None
    Beta: Annotated[
        Optional[str],
        Field(
            description='Algorithm "beta" statistic - the covariance between the algorithm and benchmark performance, divided by benchmark\'s variance.'
        ),
    ] = None
    Annual_Standard_Deviation: Annotated[
        Optional[str],
        Field(
            alias='Annual Standard Deviation',
            description='Annualized standard deviation.',
        ),
    ] = None
    Annual_Variance: Annotated[
        Optional[str],
        Field(
            alias='Annual Variance',
            description='Annualized variance statistic calculation using the daily performance variance and trading days per year.',
        ),
    ] = None
    Information_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Information Ratio',
            description='Information ratio - risk adjusted return.',
        ),
    ] = None
    Tracking_Error: Annotated[
        Optional[str],
        Field(
            alias='Tracking Error',
            description='Tracking error volatility (TEV) statistic - a measure of how closely a portfolio follows the index to which it is benchmarked.',
        ),
    ] = None
    Treynor_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Treynor Ratio',
            description='Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.',
        ),
    ] = None
    Total_Fees: Annotated[
        Optional[str], Field(alias='Total Fees', description='Total amount of fees.')
    ] = None
    Estimated_Strategy_Capacity: Annotated[
        Optional[str],
        Field(
            alias='Estimated Strategy Capacity',
            description='The estimated total capacity of the strategy at a point in time.',
        ),
    ] = None
    Lowest_Capacity_Asset: Annotated[
        Optional[str],
        Field(
            alias='Lowest Capacity Asset',
            description='Provide a reference to the lowest capacity symbol used in scaling down the capacity for debugging.',
        ),
    ] = None
    Portfolio_Turnover: Annotated[
        Optional[str],
        Field(alias='Portfolio Turnover', description='The average Portfolio Turnover'),
    ] = None


class StopLiveAlgorithmRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Project Id for the live instance we want to stop.',
            examples=[23456789],
        ),
    ]


class Symbol(BaseModel):
    value: Annotated[
        Optional[str], Field(description='The current symbol for this ticker.')
    ] = None
    id: Annotated[
        Optional[str], Field(description='The security identifier for this symbol.')
    ] = None
    permtick: Annotated[
        Optional[str], Field(description='The current symbol for this ticker.')
    ] = None


class CharlesSchwabSettings(BaseModel):
    id: Annotated[
        Optional[str], Field(description='Brokerage ID, this is, Charles Schwab.')
    ] = None
    charles_schwab_app_key: Annotated[
        Optional[str],
        Field(
            alias='charles-schwab-app-key', description='Your Charles Schwab app key.'
        ),
    ] = None
    charles_schwab_secret: Annotated[
        Optional[str],
        Field(alias='charles-schwab-secret', description='Your Charles Schwab secret.'),
    ] = None
    charles_schwab_account_number: Annotated[
        Optional[str],
        Field(
            alias='charles-schwab-account-number',
            description='Your Charles Schwab account number.',
        ),
    ] = None


class TerminalLinkConnectionType(Enum):
    DAPI = 'DAPI'
    SAPI = 'SAPI'


class TerminalLinkSettings(BaseModel):
    id: Annotated[
        Optional[str], Field(description='Brokerage ID, this is TerminalLinkBrokerage.')
    ] = None
    terminal_link_connection_type: Annotated[
        Optional[TerminalLinkConnectionType],
        Field(
            alias='terminal-link-connection-type',
            description='Terminal Link Connection Type [DAPI, SAPI].',
        ),
    ] = None
    cash: Annotated[
        Optional[List[CashAmount]], Field(description='List of cash amount.')
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class Direction2(Enum):
    Long = 'Long'
    Short = 'Short'


class Trade(BaseModel):
    symbol: Optional[Symbol] = None
    entryTime: Annotated[
        Optional[datetime], Field(description='The date and time the trade was opened.')
    ] = None
    entryPrice: Annotated[
        Optional[float],
        Field(
            description='The price at which the trade was opened (or the average price if multiple entries).'
        ),
    ] = None
    direction: Annotated[
        Optional[Direction2], Field(description='Direction of a trade.')
    ] = None
    quantity: Annotated[
        Optional[float], Field(description='The total unsigned quantity of the trade.')
    ] = None
    exitTime: Annotated[
        Optional[datetime], Field(description='The date and time the trade was closed.')
    ] = None
    exitPrice: Annotated[
        Optional[float],
        Field(
            description='The price at which the trade was closed (or the average price if multiple exits).'
        ),
    ] = None
    profitLoss: Annotated[
        Optional[float],
        Field(description='The gross profit/loss of the trade (as account currency).'),
    ] = None
    totalFees: Annotated[
        Optional[float],
        Field(
            description='The total fees associated with the trade (always positive value) (as account currency).'
        ),
    ] = None
    mae: Annotated[
        Optional[float],
        Field(description='The Maximum Adverse Excursion (as account currency).'),
    ] = None
    mfe: Annotated[
        Optional[float],
        Field(description='The Maximum Favorable Excursion (as account currency).'),
    ] = None
    duration: Annotated[
        Optional[str], Field(description='The duration of the trade.')
    ] = None
    endTradeDrawdown: Annotated[
        Optional[float],
        Field(
            description='The amount of profit given back before the trade was closed.'
        ),
    ] = None


class TradeStatistics(BaseModel):
    startDateTime: Annotated[
        Optional[datetime], Field(description='The entry date/time of the first trade')
    ] = None
    endDateTime: Annotated[
        Optional[datetime], Field(description='The exit date/time of the first trade.')
    ] = None
    totalNumberOfTrades: Annotated[
        Optional[int], Field(description='The total number of trades.')
    ] = None
    numberOfWinningTrades: Annotated[
        Optional[int], Field(description='The total number of winning trades.')
    ] = None
    numberOfLosingTrades: Annotated[
        Optional[int], Field(description='The total number of losing trades.')
    ] = None
    totalProfitLoss: Annotated[
        Optional[float],
        Field(description='The total profit/loss for all trades (as symbol currency).'),
    ] = None
    totalProfit: Annotated[
        Optional[float],
        Field(
            description='The total profit for all winning trades (as symbol currency).'
        ),
    ] = None
    totalLoss: Annotated[
        Optional[float],
        Field(description='The total loss for all losing trades (as symbol currency).'),
    ] = None
    largestProfit: Annotated[
        Optional[float],
        Field(description='The largest profit in a single trade (as symbol currency).'),
    ] = None
    largestLoss: Annotated[
        Optional[float],
        Field(description='The largest loss in a single trade (as symbol currency).'),
    ] = None
    averageProfitLoss: Annotated[
        Optional[float],
        Field(
            description='The average profit/loss (a.k.a. Expectancy or Average Trade) for all trades (as symbol currency).'
        ),
    ] = None
    averageProfit: Annotated[
        Optional[float],
        Field(
            description='The average profit for all winning trades (as symbol currency).'
        ),
    ] = None
    averageLoss: Annotated[
        Optional[float],
        Field(
            description='The average loss for all winning trades (as symbol currency).'
        ),
    ] = None
    averageTradeDuration: Annotated[
        Optional[str], Field(description='The average duration for all trades.')
    ] = None
    averageWinningTradeDuration: Annotated[
        Optional[str], Field(description='The average duration for all winning trades.')
    ] = None
    averageLosingTradeDuration: Annotated[
        Optional[str], Field(description='The average duration for all losing trades.')
    ] = None
    medianTradeDuration: Annotated[
        Optional[str], Field(description='The median duration for all trades.')
    ] = None
    medianWinningTradeDuration: Annotated[
        Optional[str], Field(description='The median duration for all winning trades.')
    ] = None
    medianLosingTradeDuration: Annotated[
        Optional[str], Field(description='The median duration for all losing trades.')
    ] = None
    maxConsecutiveWinningTrades: Annotated[
        Optional[int],
        Field(description='The maximum number of consecutive winning trades.'),
    ] = None
    maxConsecutiveLosingTrades: Annotated[
        Optional[int],
        Field(description='The maximum number of consecutive losing trades.'),
    ] = None
    profitLossRatio: Annotated[
        Optional[float],
        Field(
            description='The ratio of the average profit per trade to the average loss per trade.'
        ),
    ] = None
    winLossRatio: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of winning trades to the number of losing trades.'
        ),
    ] = None
    winRate: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of winning trades to the total number of trades.'
        ),
    ] = None
    lossRate: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of losing trades to the total number of trades.'
        ),
    ] = None
    averageMAE: Annotated[
        Optional[float],
        Field(description='The average Maximum Adverse Excursion for all trades.'),
    ] = None
    averageMFE: Annotated[
        Optional[float],
        Field(description='The average Maximum Adverse Excursion for all trades.'),
    ] = None
    largestMAE: Annotated[
        Optional[float],
        Field(description='The average Maximum Favorable Excursion for all trades.'),
    ] = None
    largestMFE: Annotated[
        Optional[float],
        Field(
            description='The largest Maximum Adverse Excursion in a single trade (as symbol currency).'
        ),
    ] = None
    maximumClosedTradeDrawdown: Annotated[
        Optional[float],
        Field(
            description='The maximum closed-trade drawdown for all trades (as symbol currency).'
        ),
    ] = None
    maximumIntraTradeDrawdown: Annotated[
        Optional[float],
        Field(
            description='The maximum intra-trade drawdown for all trades (as symbol currency).'
        ),
    ] = None
    profitLossStandardDeviation: Annotated[
        Optional[float],
        Field(
            description='The standard deviation of the profits/losses for all trades (as symbol currency).'
        ),
    ] = None
    profitLossDownsideDeviation: Annotated[
        Optional[float],
        Field(
            description='The downside deviation of the profits/losses for all trades (as symbol currency).'
        ),
    ] = None
    profitFactor: Annotated[
        Optional[float],
        Field(description='The ratio of the total profit to the total loss.'),
    ] = None
    sharpeRatio: Annotated[
        Optional[float],
        Field(
            description='The ratio of the average profit/loss to the standard deviation.'
        ),
    ] = None
    sortinoRatio: Annotated[
        Optional[float],
        Field(
            description='The ratio of the average profit/loss to the downside deviation.'
        ),
    ] = None
    profitToMaxDrawdownRatio: Annotated[
        Optional[float],
        Field(
            description='The ratio of the total profit/loss to the maximum closed trade drawdown.'
        ),
    ] = None
    maximumEndTradeDrawdown: Annotated[
        Optional[float],
        Field(
            description='The maximum amount of profit given back by a single trade before exit (as symbol currency).'
        ),
    ] = None
    averageEndTradeDrawdown: Annotated[
        Optional[float],
        Field(
            description='The average amount of profit given back by all trades before exit (as symbol currency).'
        ),
    ] = None
    maximumDrawdownDuration: Annotated[
        Optional[str],
        Field(
            description='The maximum amount of time to recover from a drawdown (longest time between new equity highs or peaks).'
        ),
    ] = None
    totalFees: Annotated[
        Optional[float], Field(description='The sum of fees for all trades.')
    ] = None


class TradierEnvironment(Enum):
    live = 'live'
    paper = 'paper'


class TradierSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='ID of the brokerage, this is, TradierBrokerage'),
    ] = None
    tradier_account_id: Annotated[
        Optional[str],
        Field(alias='tradier-account-id', description='Your Tradier account id.'),
    ] = None
    tradier_access_token: Annotated[
        Optional[str],
        Field(alias='tradier-access-token', description='Your Tradier access token.'),
    ] = None
    tradier_environment: Annotated[
        Optional[TradierEnvironment],
        Field(
            alias='tradier-environment',
            description='Whether the developer sandbox should be used.',
        ),
    ] = None


class TtRestEnvironment(Enum):
    live = 'live'
    uat = 'uat'


class TradingTechnologiesSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='Brokerage ID, this is, TradingTechnologiesBrokerage.'),
    ] = None
    tt_user_name: Annotated[
        Optional[str],
        Field(alias='tt-user-name', description='Trading Technologies user name.'),
    ] = None
    tt_session_password: Annotated[
        Optional[str],
        Field(
            alias='tt-session-password',
            description='Trading Technologies session password.',
        ),
    ] = None
    tt_account_name: Annotated[
        Optional[str],
        Field(
            alias='tt-account-name', description='Trading Technologies account name.'
        ),
    ] = None
    tt_rest_app_key: Annotated[
        Optional[str],
        Field(alias='tt-rest-app-key', description='Trading Technologies App key.'),
    ] = None
    tt_rest_app_secret: Annotated[
        Optional[str],
        Field(
            alias='tt-rest-app-secret', description='Trading Technologies App secret.'
        ),
    ] = None
    tt_rest_environment: Annotated[
        Optional[TtRestEnvironment],
        Field(
            alias='tt-rest-environment',
            description='Environment in which the brokerage Trading Technologies will be used.',
        ),
    ] = None
    tt_order_routing_sender_comp_id: Annotated[
        Optional[str],
        Field(
            alias='tt-order-routing-sender-comp-id',
            description='Trading Technologies remote comp id.',
        ),
    ] = None
    cash: Annotated[
        Optional[List[CashAmount]], Field(description='List of cash amount.')
    ] = None


class UpdateBacktestRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Project Id for the backtest we want to update.',
            examples=[23456789],
        ),
    ]
    backtestId: Annotated[
        str,
        Field(
            description='Backtest Id we want to update.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ]
    name: Annotated[
        str, Field(description='Name we would like to assign to the backtest.')
    ]
    note: Annotated[
        Optional[str], Field(description='Note attached to the backtest.')
    ] = None


class UpdateFileNameRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Project Id to which the file belongs.', examples=[23456789]),
    ]
    oldFileName: Annotated[
        str, Field(description='The current name of the file.', examples=['file1.py'])
    ]
    newName: Annotated[
        str, Field(description='The new name for the file.', examples=['file2.py'])
    ]


class UpdateFileContentsRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Project Id to which the file belongs.', examples=[23456789]),
    ]
    name: Annotated[
        str,
        Field(
            description='The name of the file that should be updated.',
            examples=['main.py'],
        ),
    ]
    content: Annotated[
        str,
        Field(
            description='The new contents of the file.',
            examples=['class CustomClass:\n    def __init__(self):\n        pass\n'],
        ),
    ]


class UpdateOptimizationRequest(BaseModel):
    optimizationId: Annotated[
        str,
        Field(
            description='Optimization ID we want to update.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ]
    name: Annotated[
        str,
        Field(
            description="Name we'd like to assign to the optimization.",
            examples=['New Optimization Name'],
        ),
    ]


class UpdateProjectRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Project Id to which the file belongs.', examples=[23456789]),
    ]
    name: Annotated[
        Optional[str],
        Field(
            description='The new name for the project.', examples=['New Project Name']
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='The new description for the project.',
            examples=['New Project Description'],
        ),
    ] = None


class UpdateProjectNodesRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Project Id to which the nodes refer.', examples=[23456789]),
    ]
    nodes: Annotated[
        Optional[List[str]],
        Field(
            description='List of node Ids the project may use. If you omit this property or pass an empty list, the best node will be automatically selected for backtest, research, and live trading.'
        ),
    ] = None


class UpdateBacktestTagsRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Project Id for the backtest we want to update.',
            examples=[23456789],
        ),
    ]
    backtestId: Annotated[Any, Field(examples=['26c7bb06b8487cff1c7b3c44652b30f1'])]
    tags: Annotated[List[str], Field(description='Array of the new backtest tags.')]


class Version(BaseModel):
    sdescription: Optional[str] = None
    bpublic: Optional[int] = None
    itimestamp: Optional[datetime] = None
    benchmark_basic: Optional[float] = None
    benchmark_equity_400_minute: Optional[float] = None
    benchmark_equity_1_second: Optional[float] = None
    benchmark_cs_indicator: Optional[float] = None
    benchmark_cs_history: Optional[float] = None
    benchmark_cs_schedule_events: Optional[float] = None
    benchmark_py_basic: Optional[float] = None
    benchmark_py_equity_400_minute: Optional[float] = None
    benchmark_py_equity_1_second: Optional[float] = None
    benchmark_py_indicator: Optional[float] = None
    benchmark_py_history: Optional[float] = None
    benchmark_py_schedule_events: Optional[float] = None
    benchmark_py_universe_coarsefine: Optional[float] = None
    benchmark_cs_universe_coarsefine: Optional[float] = None
    benchmark_py_universe_stateful: Optional[float] = None
    benchmark_cs_universe_stateful: Optional[float] = None
    benchmark_py_universe_stateless: Optional[float] = None
    benchmark_cs_universe_stateless: Optional[float] = None


class WolverineSettings(BaseModel):
    id: Annotated[
        Optional[str], Field(description='Brokerage ID, this is, WolverineBrokerage.')
    ] = None
    wolverine_on_behalf_of_comp_id: Annotated[
        Optional[str],
        Field(
            alias='wolverine-on-behalf-of-comp-id',
            description='Value used to identify the trading firm.',
        ),
    ] = None
    wolverine_account: Annotated[
        Optional[str],
        Field(
            alias='wolverine-account',
            description='Wolverine Execution Services account name.',
        ),
    ] = None
    cash: Annotated[
        Optional[List[CashAmount]], Field(description='List of cash amount.')
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class ZerodhaProductType(Enum):
    mis = 'mis'
    cnc = 'cnc'
    nrml = 'nrml'


class ZerodhaTradingSegment(Enum):
    equity = 'equity'
    commodity = 'commodity'


class ZerodhaSettings(BaseModel):
    id: Annotated[
        Optional[str], Field(description='Brokerage ID, this is, ZerodhaBrokerage.')
    ] = None
    zerodha_api_key: Annotated[
        Optional[str],
        Field(alias='zerodha-api-key', description='Your Kite Connect API key.'),
    ] = None
    zerodha_access_token: Annotated[
        Optional[str],
        Field(
            alias='zerodha-access-token', description='Your Kite Connect access token.'
        ),
    ] = None
    zerodha_product_type: Annotated[
        Optional[ZerodhaProductType],
        Field(
            alias='zerodha-product-type',
            description='The product type must be set to MIS if you are targeting intraday products, CNC if you are targeting delivery products or NRML if you are targeting carry forward products.',
        ),
    ] = None
    zerodha_trading_segment: Annotated[
        Optional[ZerodhaTradingSegment],
        Field(
            alias='zerodha-trading-segment',
            description="The trading segment must be set to 'equity' if you are trading equities on NSE or BSE, or 'commodity' if you are trading commodities on MCX.",
        ),
    ] = None
    zerodha_history_subscription: Annotated[
        Optional[bool],
        Field(
            alias='zerodha-history-subscription',
            description='Whether you have a history API subscription for Zerodha.',
        ),
    ] = None


class FilesUpdateBody(BaseModel):
    RootModel: Union[UpdateFileNameRequest, UpdateFileContentsRequest]


class GetObjectStore(BaseModel):
    RootModel: Union[GetObjectStoreJobIdRequest, GetObjectStoreURLRequest]


class BasicFilesRequest(BaseModel):
    language: Annotated[
        Language, Field(description='Programming language.', examples=['Py'])
    ]
    files: Annotated[
        List[File],
        Field(
            description='Files to process.',
            examples=['[{"name": "file.py", "content": "fileContent"}]'],
        ),
    ]


class ErrorEnhanceRequest(BaseModel):
    language: Annotated[
        Language,
        Field(
            description='Programming language for the code completion.', examples=['Py']
        ),
    ]
    error: Annotated[Error, Field(description='Error message to enhance.')]


class PEP8ConvertRequest(BaseModel):
    files: Annotated[
        List[File],
        Field(
            description='Files present in the project in which the algorithm is.',
            examples=['[{"name": "file.py", "content": "fileContent"}]'],
        ),
    ]


class SearchRequest(BaseModel):
    language: Annotated[
        Language,
        Field(
            description='Programming language of the content to search.',
            examples=['Py'],
        ),
    ]
    criteria: Annotated[
        List[SearchCriteria],
        Field(
            description='Criteria for the search.',
            examples=['[{"input": "option", "type": "Docs", "count": 1}]'],
        ),
    ]


class SearchResponse(BaseModel):
    state: Annotated[
        Optional[str], Field(description='State of the search.', examples=['End'])
    ] = None
    version: Annotated[
        Optional[str], Field(description='Version of the response.', examples=[2.0])
    ] = None
    retrivals: Annotated[
        Optional[List[SearchRetrieval]], Field(description='List of search results.')
    ] = None
    messageId: Annotated[
        Optional[int], Field(description='ID of the message.', examples=[0])
    ] = None


class AccountResponse(BaseModel):
    organizationId: Annotated[
        Optional[str],
        Field(
            description='The organization Id.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ] = None
    creditBalance: Annotated[
        Optional[float], Field(description='The current account balance.')
    ] = None
    card: Annotated[
        Optional[Card], Field(description='The current organizations credit card.')
    ] = None


class AlgorithmPerformance(BaseModel):
    tradeStatistics: Optional[TradeStatistics] = None
    portfolioStatistics: Optional[PortfolioStatistics] = None
    closedTrades: Annotated[
        Optional[List[Trade]],
        Field(description='The algorithm statistics on portfolio.'),
    ] = None


class BacktestInsightsResponse(BaseModel):
    insights: Annotated[
        Optional[List[Insight]], Field(description='Collection of insights.')
    ] = None
    length: Annotated[
        Optional[int], Field(description='Total number of returned insights')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class BacktestResult(BaseModel):
    note: Annotated[
        Optional[str], Field(description='Note on the backtest attached by the user.')
    ] = None
    name: Annotated[Optional[str], Field(description='Name of the backtest.')] = None
    organizationId: Annotated[
        Optional[str],
        Field(
            description='Orgainization ID.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ] = None
    projectId: Annotated[
        Optional[int], Field(description='Project ID', examples=[23456789])
    ] = None
    completed: Annotated[
        Optional[bool],
        Field(description='Boolean true when the backtest is completed.'),
    ] = None
    optimizationId: Annotated[
        Optional[str],
        Field(
            description='Optimization task ID, if the backtest is part of an optimization.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ] = None
    backtestId: Annotated[
        Optional[str],
        Field(
            description='Assigned backtest ID.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ] = None
    tradeableDates: Annotated[
        Optional[int], Field(description='Number of traadeable days.')
    ] = None
    researchGuide: Annotated[
        Optional[ResearchGuide],
        Field(
            description='A power gauge for backtests, time and parameters to estimate the overfitting risk.'
        ),
    ] = None
    backtestStart: Annotated[
        Optional[datetime], Field(description='The starting time of the backtest')
    ] = None
    backtestEnd: Annotated[
        Optional[datetime], Field(description='The ending time of the backtest')
    ] = None
    created: Annotated[
        Optional[datetime], Field(description='Backtest creation date and time.')
    ] = None
    snapshotId: Annotated[
        Optional[int], Field(description='Snapshot id of this backtest result.')
    ] = None
    status: Annotated[
        Optional[Status], Field(description='Status of the backtest.')
    ] = None
    error: Annotated[Optional[str], Field(description='Backtest error message.')] = None
    stacktrace: Annotated[
        Optional[str], Field(description='Backtest error stacktrace.')
    ] = None
    progress: Annotated[
        Optional[float], Field(description='Progress of the backtest in percent 0-1.')
    ] = None
    hasInitializeError: Annotated[
        Optional[bool],
        Field(description='Indicates if the backtest has error during initialization.'),
    ] = None
    charts: Annotated[
        Optional[Dict[str, ChartSummary]],
        Field(
            description='Charts updates for the live algorithm since the last result packet.'
        ),
    ] = None
    parameterSet: Annotated[
        Optional[Dict[str, ParameterSet]],
        Field(description='Parameters used in the backtest.'),
    ] = None
    rollingWindow: Annotated[
        Optional[Dict[str, AlgorithmPerformance]],
        Field(description='Rolling window detailed statistics.'),
    ] = None
    runtimeStatistics: Annotated[
        Optional[Dict[str, RuntimeStatistics]],
        Field(
            description='Runtime banner/updating statistics in the title banner of the live algorithm GUI.'
        ),
    ] = None
    statistics: Annotated[
        Optional[Dict[str, StatisticsResult]],
        Field(
            description='Statistics information sent during the algorithm operations.'
        ),
    ] = None
    totalPerformance: Annotated[
        Optional[Dict[str, AlgorithmPerformance]],
        Field(description='The algorithm performance statistics.'),
    ] = None
    nodeName: Annotated[Optional[str], Field(description='The backtest node name.')] = (
        None
    )
    outOfSampleMaxEndDate: Annotated[
        Optional[datetime], Field(description='End date of out of sample data.')
    ] = None
    outOfSampleDays: Annotated[
        Optional[int], Field(description='Number of days of out of sample days.')
    ] = None


class BacktestSummaryResult(BaseModel):
    backtestId: Annotated[
        Optional[str],
        Field(
            description='Assigned backtest ID',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ] = None
    status: Annotated[
        Optional[Status], Field(description='Status of the backtest.')
    ] = None
    name: Annotated[Optional[str], Field(description='Name of the backtest.')] = None
    created: Annotated[
        Optional[datetime], Field(description='Backtest creation date and time.')
    ] = None
    progress: Annotated[
        Optional[float], Field(description='Progress of the backtest in percent 0-1.')
    ] = None
    optimizationId: Annotated[
        Optional[str],
        Field(
            description='Optimization task ID, if the backtest is part of an optimization.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ] = None
    tradeableDates: Annotated[
        Optional[int], Field(description='Number of traadeable days')
    ] = None
    parameterSet: Annotated[
        Optional[Dict[str, ParameterSet]],
        Field(description='Parameters used in the backtest.'),
    ] = None
    snapshotId: Annotated[
        Optional[int], Field(description='Snapshot id of this backtest result.')
    ] = None
    tags: Annotated[
        Optional[List[str]], Field(description='Collection of tags for the backtest.')
    ] = None
    sharpeRatio: Annotated[
        Optional[float],
        Field(
            description='Sharpe ratio with respect to risk free rate; measures excess of return per unit of risk.'
        ),
    ] = None
    alpha: Annotated[
        Optional[float],
        Field(
            description='Algorithm "Alpha" statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns.'
        ),
    ] = None
    beta: Annotated[
        Optional[float],
        Field(
            description='Algorithm "beta" statistic - the covariance between the algorithm and benchmark performance, divided by benchmark\'s variance.'
        ),
    ] = None
    compoundingAnnualReturn: Annotated[
        Optional[float],
        Field(
            description='Annual compounded returns statistic based on the final-starting capital and years.'
        ),
    ] = None
    drawdown: Annotated[
        Optional[float], Field(description='Drawdown maximum percentage.')
    ] = None
    lossRate: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of losing trades to the total number of trades.'
        ),
    ] = None
    netProfit: Annotated[
        Optional[float], Field(description='Net profit percentage.')
    ] = None
    parameters: Annotated[
        Optional[int], Field(description='Number of parameters in the backtest.')
    ] = None
    psr: Annotated[Optional[float], Field(description='Price-to-sales ratio.')] = None
    securityTypes: Annotated[
        Optional[str], Field(description='SecurityTypes present in the backtest.')
    ] = None
    sortinoRatio: Annotated[
        Optional[float],
        Field(
            description='Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.'
        ),
    ] = None
    trades: Annotated[
        Optional[int], Field(description='Number of trades in the backtest.')
    ] = None
    treynorRatio: Annotated[
        Optional[float],
        Field(
            description='Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.'
        ),
    ] = None
    winRate: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of winning trades to the total number of trades.'
        ),
    ] = None


class BinanceSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='ID of the brokerage, this is, BinanceBrokerage'),
    ] = None
    binance_exchange_name: Annotated[
        Optional[str],
        Field(
            alias='binance-exchange-name',
            description='Binance exchange, this is, Binance.',
        ),
    ] = None
    binance_api_secret: Annotated[
        Optional[str],
        Field(alias='binance-api-secret', description='Your Binance API secret.'),
    ] = None
    binance_api_key: Annotated[
        Optional[str],
        Field(alias='binance-api-key', description='Your Binance API key.'),
    ] = None
    binance_api_url: Annotated[
        Optional[str],
        Field(
            alias='binance-api-url',
            description='Binance configuration for spot/margin. The value for this property is https://api.binance.com',
        ),
    ] = None
    binance_websocket_url: Annotated[
        Optional[str],
        Field(
            alias='binance-websocket-url',
            description='Binance configuration for spot/margin. The value for this property is wss://stream.binance.com:9443/ws',
        ),
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class BinanceFuturesUSDMSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='ID of the brokerage, this is, BinanceBrokerage'),
    ] = None
    binance_exchange_name: Annotated[
        Optional[str],
        Field(
            alias='binance-exchange-name',
            description='Binance exchange, this is, Binance-USDM-Futures.',
        ),
    ] = None
    binance_api_secret: Annotated[
        Optional[str],
        Field(alias='binance-api-secret', description='Your Binance API secret.'),
    ] = None
    binance_api_key: Annotated[
        Optional[str],
        Field(alias='binance-api-key', description='Your Binance API key.'),
    ] = None
    binance_fapi_url: Annotated[
        Optional[str],
        Field(
            alias='binance-fapi-url',
            description='Binance Futures configuration for spot/margin. The value for this property is https://fapi.binance.com',
        ),
    ] = None
    binance_fwebsocket_url: Annotated[
        Optional[str],
        Field(
            alias='binance-fwebsocket-url',
            description='Binance Futures configuration for spot/margin. The value for this property is wss://fstream.binance.com/ws',
        ),
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class BinanceFuturesCOINSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='ID of the brokerage, this is, BinanceBrokerage'),
    ] = None
    binance_exchange_name: Annotated[
        Optional[str],
        Field(
            alias='binance-exchange-name',
            description='Binance exchange, this is, Binance-COIN-Futures.',
        ),
    ] = None
    binance_api_secret: Annotated[
        Optional[str],
        Field(alias='binance-api-secret', description='Your Binance API secret.'),
    ] = None
    binance_api_key: Annotated[
        Optional[str],
        Field(alias='binance-api-key', description='Your Binance API key.'),
    ] = None
    binance_dapi_url: Annotated[
        Optional[str],
        Field(
            alias='binance-dapi-url',
            description='Binance Futures configuration for spot/margin. The value for this property is https://dapi.binance.com',
        ),
    ] = None
    binance_dwebsocket_url: Annotated[
        Optional[str],
        Field(
            alias='binance-dwebsocket-url',
            description='Binance Futures configuration for spot/margin. The value for this property is wss://dstream.binance.com/ws',
        ),
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class BinanceUSSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='ID of the brokerage, this is, BinanceBrokerage.'),
    ] = None
    binance_exchange_name: Annotated[
        Optional[str],
        Field(
            alias='binance-exchange-name',
            description='Binance exchange, this is, BinanceUS.',
        ),
    ] = None
    binanceus_api_secret: Annotated[
        Optional[str],
        Field(alias='binanceus-api-secret', description='Your Binance US API secret.'),
    ] = None
    binanceus_api_key: Annotated[
        Optional[str],
        Field(alias='binanceus-api-key', description='Your Binance US API key.'),
    ] = None
    binanceus_api_url: Annotated[
        Optional[str],
        Field(
            alias='binanceus-api-url',
            description='Binance US configuration for spot/margin. The value for this property is https://api.binance.us',
        ),
    ] = None
    binanceus_websocket_url: Annotated[
        Optional[str],
        Field(
            alias='binanceus-websocket-url',
            description='Binance US configuration for spot/margin. The value for this property is wss://stream.binance.us:9443/ws',
        ),
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class BrokerageData(BaseModel):
    authentication: Optional[LiveAuthenticationData] = None
    additionalProperties: Optional[BrokerageId] = None


class BybitSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='ID of the brokerage, this is, BybitBrokerage.'),
    ] = None
    bybit_api_key: Annotated[
        Optional[str], Field(alias='bybit-api-key', description='Your Bybit API key.')
    ] = None
    bybit_api_secret: Annotated[
        Optional[str],
        Field(alias='bybit-api-secret', description='Your Bybit API secret.'),
    ] = None
    bybit_vip_level: Annotated[
        Optional[str],
        Field(alias='bybit-vip-level', description='Your Bybit VIP Level.'),
    ] = None
    bybit_use_testnet: Annotated[
        Optional[BybitUseTestnet],
        Field(
            alias='bybit-use-testnet', description='Whether the testnet should be used.'
        ),
    ] = None
    bybit_api_url: Annotated[
        Optional[str],
        Field(
            alias='bybit-api-url',
            description='Bybit API URL, this is, https://api-testnet.bybit.com',
        ),
    ] = None
    bybit_websocket_url: Annotated[
        Optional[str],
        Field(
            alias='bybit-websocket-url',
            description='Bybit Websocket URL, this is, wss://stream.bybit.com',
        ),
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class Chart(BaseModel):
    name: Annotated[Optional[str], Field(description='Name of the Chart.')] = None
    chartType: Annotated[
        Optional[ChartType],
        Field(description='Type of the Chart, Overlayed or Stacked.'),
    ] = None
    series: Annotated[
        Optional[Dict[str, Series]],
        Field(description='List of Series Objects for this Chart.'),
    ] = None


class CoinbaseSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(description='ID of the brokerage, this is, CoinbaseBrokerage'),
    ] = None
    coinbase_api_key: Annotated[
        Optional[str],
        Field(
            alias='coinbase-api-key',
            description='Your Coinbase Advanced Trade API key.',
        ),
    ] = None
    coinbase_api_secret: Annotated[
        Optional[str],
        Field(
            alias='coinbase-api-secret',
            description='Your Coinbase Advanced Trade API secret.',
        ),
    ] = None
    coinbase_url: Annotated[
        Optional[str],
        Field(
            alias='coinbase-url',
            description='Coinbase URL, this is, wss://advanced-trade-ws.coinbase.com',
        ),
    ] = None
    coinbase_rest_api: Annotated[
        Optional[str],
        Field(
            alias='coinbase-rest-api',
            description='Coinbase REST API, this is, https://api.coinbase.com',
        ),
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class FileParameters(BaseModel):
    file: Annotated[
        Optional[str],
        Field(
            description='Path of the file in the project.',
            examples=['__init__.py', 'project/main.py'],
        ),
    ] = None
    parameters: Annotated[
        Optional[List[ParameterDetail]],
        Field(description='List of parameters detected in the file.'),
    ] = None


class CreateLiveAlgorithmResponse(BaseModel):
    live: Annotated[
        Optional[LiveAlgorithm], Field(description='Echo of the algorithm created.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class CreateOptimizationRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Project ID of the project the optimization belongs to.',
            examples=[23456789],
        ),
    ]
    name: Annotated[
        str,
        Field(
            description='Name of the optimization.',
            examples=['Mia First Optimization Job'],
        ),
    ]
    target: Annotated[
        str,
        Field(
            description='Target of the optimization.',
            examples=['TotalPerformance.PortfolioStatistics.SharpeRatio'],
        ),
    ]
    targetTo: Annotated[
        str,
        Field(
            description='Target extremum of the optimization.',
            examples=["\\'max\\' or \\'min\\'"],
        ),
    ]
    targetValue: Annotated[
        float, Field(description='Optimization target value.', examples=[1])
    ]
    strategy: Annotated[
        str,
        Field(
            description='Optimization strategy.',
            examples=[
                'QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy'
            ],
        ),
    ]
    compileId: Annotated[
        str,
        Field(
            description='Optimization compile ID.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ]
    parameters: Annotated[
        List[OptimizationParameter], Field(description='Optimization parameters.')
    ]
    constraints: Annotated[
        Optional[List[OptimizationConstraint]],
        Field(description='Optimization constraints.'),
    ] = None
    estimatedCost: Annotated[
        float, Field(description='Estimated cost for optimization.', examples=[10])
    ]
    nodeType: Annotated[
        NodeType, Field(description='Optimization node type.', examples=['O2-8'])
    ]
    parallelNodes: Annotated[
        int,
        Field(description='Number of parallel nodes for optimization.', examples=[4]),
    ]


class CreateOptimizationResponse(BaseModel):
    optimizationId: Annotated[
        Optional[str],
        Field(
            description='Optimization ID.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ] = None
    projectId: Annotated[
        Optional[int],
        Field(
            description='Project ID of the project the optimization belongs to.',
            examples=[23456789],
        ),
    ] = None
    name: Annotated[Optional[str], Field(description='Name of the optimization.')] = (
        None
    )
    status: Annotated[
        Optional[Status2], Field(description='Status of the optimization.')
    ] = None
    nodeType: Annotated[
        Optional[NodeType],
        Field(description='Optimization node type.', examples=['O2-8']),
    ] = None
    criterion: Annotated[
        Optional[OptimizationTarget],
        Field(description='Optimization statistical target.'),
    ] = None
    created: Annotated[
        Optional[datetime],
        Field(description='Date when this optimization was created.'),
    ] = None
    psr: Annotated[Optional[float], Field(description='Price-sales ratio stastic.')] = (
        None
    )
    sharpeRatio: Annotated[
        Optional[float], Field(description='Sharpe ratio statistic.')
    ] = None
    trades: Annotated[Optional[int], Field(description='Number of trades.')] = None
    cloneId: Annotated[
        Optional[int],
        Field(
            description='ID of project, were this current project was originally cloned.'
        ),
    ] = None
    outOfSampleDays: Annotated[
        Optional[int], Field(description='Number of days of out of sample days.')
    ] = None
    outOfSampleMaxEndDate: Annotated[
        Optional[datetime], Field(description='End date of out of sample data.')
    ] = None
    parameters: Annotated[
        Optional[List[OptimizationParameter]],
        Field(description='Parameters used in this optimization.'),
    ] = None


class EstimateOptimizationRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Project ID of the project the optimization belongs to.',
            examples=[23456789],
        ),
    ]
    name: Annotated[
        str,
        Field(
            description='Name of the optimization.',
            examples=['Mia First Optimization Job'],
        ),
    ]
    target: Annotated[
        str,
        Field(
            description='Target of the optimization.',
            examples=['TotalPerformance.PortfolioStatistics.SharpeRatio'],
        ),
    ]
    targetTo: Annotated[
        str,
        Field(
            description='Target extremum of the optimization.',
            examples=["\\'max\\' or \\'min\\'"],
        ),
    ]
    targetValue: Annotated[
        float, Field(description='Optimization target value.', examples=[1])
    ]
    strategy: Annotated[
        str,
        Field(
            description='Optimization strategy.',
            examples=[
                'QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy'
            ],
        ),
    ]
    compileId: Annotated[
        str,
        Field(
            description='Optimization compile ID.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ]
    parameters: Annotated[
        List[OptimizationParameter], Field(description='Optimization parameters.')
    ]
    constraints: Annotated[
        Optional[List[OptimizationConstraint]],
        Field(description='Optimization constraints.'),
    ] = None


class GetObjectStorePropertiesResponse(BaseModel):
    metadata: Annotated[
        Optional[ObjectStoreProperties], Field(description='Object Store properties.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class Grid(BaseModel):
    xs: Annotated[
        Optional[List[GridChart]],
        Field(description='List of chart in the xs (Extra small) position.'),
    ] = None
    sm: Annotated[
        Optional[List[GridChart]],
        Field(description='List of chart in the sm (Small) position.'),
    ] = None
    md: Annotated[
        Optional[List[GridChart]],
        Field(description='List of chart in the md (Medium) position.'),
    ] = None
    lg: Annotated[
        Optional[List[GridChart]],
        Field(description='List of chart in the lg (Large) position.'),
    ] = None
    xl: Annotated[
        Optional[List[GridChart]],
        Field(description='List of chart in the xl (Extra large) position.'),
    ] = None


class Holding(BaseModel):
    symbol: Optional[Symbol] = None
    type: Annotated[
        Optional[Type],
        Field(description='Type of tradable security / underlying asset.'),
    ] = None
    currencySymbol: Annotated[
        Optional[str],
        Field(description='The currency symbol of the holding.', examples=['$']),
    ] = None
    averagePrice: Annotated[
        Optional[float],
        Field(
            description='Average Price of our Holding in the currency the symbol is traded in.'
        ),
    ] = None
    quantity: Annotated[
        Optional[float], Field(description='Quantity of the Symbol we hold.')
    ] = None
    marketPrice: Annotated[
        Optional[float],
        Field(
            description='Current Market Price of the Asset in the currency the symbol is traded in.'
        ),
    ] = None
    conversionRate: Annotated[
        Optional[float],
        Field(description='Current market conversion rate into the account currency.'),
    ] = None
    marketValue: Annotated[
        Optional[float], Field(description='Current market value of the holding.')
    ] = None
    unrealizedPnl: Annotated[
        Optional[float], Field(description='Current unrealized P/L of the holding.')
    ] = None


class LeanVersionsResponse(BaseModel):
    versions: Annotated[
        Optional[List[LeanVersion]],
        Field(description='List of LEAN versions with their basic descriptions.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class LiveForm(BaseModel):
    brokerageData: Optional[BrokerageData] = None
    dataProvidersData: Annotated[
        Optional[List[BrokerageId]],
        Field(description='The data providers used in the live deployment.'),
    ] = None
    node: Annotated[
        Optional[str], Field(description='Node ID of the live node deployed.')
    ] = None
    notifyInsights: Annotated[
        Optional[NotifyInsights],
        Field(
            description='Indicates if notification should be issued on new insights.'
        ),
    ] = None
    notifyOrderEvents: Annotated[
        Optional[NotifyOrderEvents],
        Field(
            description='Indicates if notification should be issued on new order events.'
        ),
    ] = None
    autoRestart: Annotated[
        Optional[AutoRestart],
        Field(
            description='Indicates if the live algorithm should automatically restart after encountering runtime errors.'
        ),
    ] = None


class LiveAlgorithmResults(BaseModel):
    message: Annotated[
        Optional[str], Field(description='Error message.', examples=['message'])
    ] = None
    status: Annotated[
        Optional[str],
        Field(
            description="Indicates the status of the algorihtm, i.e. 'Running', 'Stopped'.",
            examples=['Running'],
        ),
    ] = None
    deployId: Annotated[
        Optional[str],
        Field(
            description='Algorithm deployment ID.',
            examples=['L-sdf86b7045bb83203e79d2aa6150b321'],
        ),
    ] = None
    cloneId: Annotated[
        Optional[int],
        Field(
            description="The snapshot project ID for cloning the live development's source code."
        ),
    ] = None
    launched: Annotated[
        Optional[str], Field(description='Date the live algorithm was launched.')
    ] = None
    stopped: Annotated[
        Optional[str], Field(description='Date the live algorithm was stopped.')
    ] = None
    brokerage: Annotated[
        Optional[str], Field(description='Brokerage used in the live algorithm.')
    ] = None
    securityTypes: Annotated[
        Optional[str],
        Field(description='Security types present in the live algorithm.'),
    ] = None
    projectName: Annotated[
        Optional[str],
        Field(description='Name of the project the live algorithm is in.'),
    ] = None
    dataCenter: Annotated[
        Optional[str],
        Field(
            description='Name of the data center where the algorithm is physically located.'
        ),
    ] = None
    public: Annotated[
        Optional[bool],
        Field(description='Indicates if the algorithm is being live shared.'),
    ] = None
    files: Annotated[
        Optional[List[ProjectFile]],
        Field(description='Files present in the project in which the algorithm is.'),
    ] = None
    runtimeStatistics: Annotated[
        Optional[Dict[str, RuntimeStatistics]],
        Field(
            description='Runtime banner/updating statistics in the title banner of the live algorithm GUI. It can be empty if the algorithm is not running.'
        ),
    ] = None
    charts: Annotated[
        Optional[Dict[str, ChartSummary]],
        Field(
            description='Chart updates for the live algorithm since the last result packet.'
        ),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ListObjectStoreResponse(BaseModel):
    path: Annotated[
        Optional[str],
        Field(description='Path to the files in the Object Store.', examples=['Mia']),
    ] = None
    objects: Annotated[
        Optional[List[ObjectStoreSummary]], Field(description='List of objects stored.')
    ] = None
    objectStorageUsed: Annotated[
        Optional[int], Field(description='Size of all objects stored in bytes.')
    ] = None
    objectStorageUsedHuman: Annotated[
        Optional[str],
        Field(description='Size of all the objects stored in human-readable format.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ListOptimizationResponse(BaseModel):
    optimizations: Annotated[
        Optional[List[CreateOptimizationResponse]],
        Field(description='Collection of summarized optimization objects.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class LivePortfolioResponse(BaseModel):
    portfolio: Optional[Portfolio] = None


class Node(BaseModel):
    speed: Annotated[
        Optional[float], Field(description='The nodes cpu clock speed in GHz.')
    ] = None
    price: Annotated[
        Optional[NodePrices],
        Field(description='The monthly and yearly prices of the node in US dollars.'),
    ] = None
    cpu: Annotated[Optional[int], Field(description='CPU core count of node.')] = None
    ram: Annotated[Optional[float], Field(description='Size of RAM in Gigabytes.')] = (
        None
    )
    name: Annotated[Optional[str], Field(description='Name of the node.')] = None
    sku: Annotated[
        Optional[str], Field(description='Node type identifier for configuration.')
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the node.')
    ] = None
    usedBy: Annotated[
        Optional[str], Field(description='User currently using the node.')
    ] = None
    userProfile: Annotated[
        Optional[str], Field(description='URL of the user using the node.')
    ] = None
    projectName: Annotated[
        Optional[str], Field(description='Project the node is being used for.')
    ] = None
    projectId: Annotated[
        Optional[int],
        Field(
            description='Id of the project the node is being used for.',
            examples=[23456789],
        ),
    ] = None
    busy: Annotated[
        Optional[bool], Field(description='Indicates if the node is currently busy.')
    ] = None
    id: Annotated[Optional[str], Field(description='Full Id of node.')] = None
    assets: Annotated[
        Optional[int],
        Field(description='Maximum number of assets recommended for this node.'),
    ] = None
    host: Annotated[Optional[str], Field(description='Node host.')] = None
    active: Annotated[
        Optional[bool],
        Field(
            description="Indicate if this is an active node for the project. The project will use this node if it's not busy."
        ),
    ] = None
    hasGpu: Annotated[
        Optional[int], Field(description='Indicate if the node has GPU (1) or not (0).')
    ] = None


class ProjectNodes(BaseModel):
    backtest: Annotated[
        Optional[List[Node]], Field(description='Collection of backtest nodes.')
    ] = None
    live: Annotated[
        Optional[List[Node]], Field(description='Collection of live nodes.')
    ] = None
    research: Annotated[
        Optional[List[Node]], Field(description='Collection of research nodes.')
    ] = None


class Optimization(BaseModel):
    optimizationId: Annotated[
        Optional[str],
        Field(
            description='Optimization ID.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ] = None
    snapshotId: Annotated[
        Optional[str], Field(description='Snapshot iD of this optimization.')
    ] = None
    projectId: Annotated[
        str,
        Field(
            description='Project ID of the project the optimization belongs to.',
            examples=[23456789],
        ),
    ]
    name: Annotated[Optional[str], Field(description='Name of the optimization.')] = (
        None
    )
    status: Annotated[
        Optional[Status4], Field(description='Status of the optimization.')
    ] = None
    nodeType: Annotated[
        Optional[NodeType3],
        Field(description='Optimization node type.', examples=['O2-8']),
    ] = None
    parallelNodes: Annotated[
        Optional[int],
        Field(description='Number of parallel nodes for optimization.', examples=[4]),
    ] = None
    criterion: Annotated[
        Optional[OptimizationTarget],
        Field(description='Optimization statistical target.'),
    ] = None
    runtimeStatistics: Annotated[
        Optional[Dict[str, str]],
        Field(
            description='Dictionary representing a runtime banner/updating statistics for the optimization.'
        ),
    ] = None
    constraints: Annotated[
        Optional[List[OptimizationConstraint]],
        Field(description='Optimization constraints.'),
    ] = None
    parameters: Annotated[
        Optional[List[OptimizationParameter]],
        Field(description='Optimization parameters.'),
    ] = None
    backtests: Annotated[
        Optional[Union[List[OptimizationBacktest], Backtests]],
        Field(description='Dictionary of optimization backtests.'),
    ] = None
    strategy: Annotated[
        Optional[str],
        Field(
            description='Optimization strategy.',
            examples=[
                'QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy'
            ],
        ),
    ] = None
    requested: Annotated[
        Optional[datetime], Field(description='Optimization requested date and time.')
    ] = None
    optimizationTarget: Annotated[
        Optional[str], Field(description='Statistic to be optimized.')
    ] = None
    gridLayout: Annotated[
        Optional[List[GridChart]],
        Field(description='List with grid charts representing the grid layout.'),
    ] = None
    outOfSampleMaxEndDate: Annotated[
        Optional[str], Field(description='End date of out of sample data.')
    ] = None
    outOfSampleDays: Annotated[
        Optional[int], Field(description='Number of days of out of sample days.')
    ] = None


class Order(BaseModel):
    id: Annotated[Optional[int], Field(description='Order ID.')] = None
    contingentId: Annotated[
        Optional[int],
        Field(description='Order Id to process before processing this order.'),
    ] = None
    brokerId: Annotated[
        Optional[List[str]],
        Field(
            description='Brokerage Id for this order for when the brokerage splits orders into multiple pieces.'
        ),
    ] = None
    symbol: Annotated[Optional[Symbol], Field(description='Symbol of the asset.')] = (
        None
    )
    limitPrice: Annotated[
        Optional[float], Field(description='Limit price of the Order.')
    ] = None
    stopPrice: Annotated[
        Optional[float], Field(description='Stop price of the Order.')
    ] = None
    stopTriggered: Annotated[
        Optional[bool],
        Field(
            description='Indicates if the stop price has been reached, so the limit order has been triggered.'
        ),
    ] = None
    price: Annotated[Optional[float], Field(description='Price of the Order.')] = None
    priceCurrency: Annotated[
        Optional[str], Field(description='Currency for the order price.')
    ] = None
    time: Annotated[
        Optional[datetime],
        Field(description='Gets the utc time the order was created.'),
    ] = None
    createdTime: Annotated[
        Optional[datetime],
        Field(description='Gets the utc time this order was created. Alias for Time.'),
    ] = None
    lastFillTime: Annotated[
        Optional[datetime],
        Field(
            description='Gets the utc time the last fill was received, or null if no fills have been received.'
        ),
    ] = None
    lastUpdateTime: Annotated[
        Optional[datetime],
        Field(
            description='Gets the utc time this order was last updated, or null if the order has not been updated.'
        ),
    ] = None
    canceledTime: Annotated[
        Optional[datetime],
        Field(
            description='Gets the utc time this order was canceled, or null if the order was not canceled.'
        ),
    ] = None
    quantity: Annotated[
        Optional[float], Field(description='Number of shares to execute.')
    ] = None
    type: Annotated[Optional[Type2], Field(description='Order type.')] = None
    status: Annotated[Optional[Status5], Field(description='Status of the Order.')] = (
        None
    )
    tag: Annotated[
        Optional[str], Field(description='Tag the order with some custom data.')
    ] = None
    securityType: Annotated[
        Optional[SecurityType],
        Field(description='Type of tradable security / underlying asset.'),
    ] = None
    direction: Annotated[
        Optional[Direction1],
        Field(description='Order Direction Property based off Quantity.'),
    ] = None
    value: Annotated[
        Optional[float],
        Field(
            description='Gets the executed value of this order. If the order has not yet filled, then this will return zero.'
        ),
    ] = None
    orderSubmissionData: Annotated[
        Optional[OrderSubmissionData],
        Field(description='Gets the price data at the time the order was submitted.'),
    ] = None
    isMarketable: Annotated[
        Optional[bool],
        Field(description='Returns true if the order is a marketable order.'),
    ] = None
    properties: Annotated[
        Optional[OrderProperties],
        Field(description='Additional properties of the order.'),
    ] = None
    events: Annotated[
        Optional[List[OrderEvent]], Field(description='The order events.')
    ] = None
    trailingAmount: Annotated[
        Optional[float], Field(description='Trailing amount for a trailing stop order.')
    ] = None
    trailingPercentage: Annotated[
        Optional[bool],
        Field(
            description='Determines whether the trailingAmount is a percentage or an absolute currency value.'
        ),
    ] = None
    groupOrderManager: Annotated[
        Optional[GroupOrderManager],
        Field(
            description='Manager for the orders in the group if this is a combo order.'
        ),
    ] = None
    triggerPrice: Annotated[
        Optional[float],
        Field(
            description='The price which, when touched, will trigger the setting of a limit order at limitPrice.'
        ),
    ] = None
    triggerTouched: Annotated[
        Optional[bool],
        Field(description='Whether or not the triggerPrice has been touched.'),
    ] = None


class Project(BaseModel):
    projectId: Annotated[int, Field(description='Project id.', examples=[23456789])]
    organizationId: Annotated[
        str,
        Field(
            description='Orgainization id.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    name: Annotated[str, Field(description='Name of the project.')]
    modified: Annotated[datetime, Field(description='Modified date for the project.')]
    created: Annotated[datetime, Field(description='Date the project was created.')]
    ownerId: Annotated[int, Field(description='Owner id.')]
    language: Annotated[
        Language, Field(description='Programming language of the project.')
    ]
    collaborators: Annotated[
        Optional[List[Collaborator]], Field(description='List of collaborators.')
    ] = None
    leanVersionId: Annotated[
        Optional[int],
        Field(description='The version of LEAN this project is running on.'),
    ] = None
    leanPinnedToMaster: Annotated[
        Optional[bool],
        Field(
            description='Indicate if the project is pinned to the master branch of LEAN.'
        ),
    ] = None
    owner: Annotated[
        Optional[bool],
        Field(description='Indicate if you are the owner of the project.'),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The project description.')
    ] = None
    channelId: Annotated[Optional[str], Field(description='Channel id.')] = None
    parameters: Annotated[
        Optional[List[ParameterSet]], Field(description='Optimization parameters.')
    ] = None
    libraries: Annotated[
        Optional[List[Library]], Field(description='The library projects.')
    ] = None
    grid: Annotated[
        Optional[Grid], Field(description='Configuration of the backtest view grid.')
    ] = None
    liveGrid: Annotated[
        Optional[Grid], Field(description='Configuration of the live view grid.')
    ] = None
    paperEquity: Annotated[
        Optional[float],
        Field(description='The equity value of the last paper trading instance.'),
    ] = None
    lastLiveDeployment: Annotated[
        Optional[datetime], Field(description='The last live deployment active time.')
    ] = None
    liveForm: Annotated[
        Optional[LiveForm], Field(description='The last live wizard content used.')
    ] = None
    encrypted: Annotated[
        Optional[bool], Field(description='Indicates if the project is encrypted.')
    ] = None
    codeRunning: Annotated[
        Optional[bool], Field(description='Indicates if the project is running or not.')
    ] = None
    leanEnvironment: Annotated[
        Optional[int], Field(description='LEAN environment of the project running on.')
    ] = None
    encryptionKey: Annotated[
        Optional[EncryptionKey],
        Field(
            description='Text file with at least 32 characters to be used to encrypt the project.'
        ),
    ] = None


class ProjectListResponse(BaseModel):
    projects: Annotated[
        Optional[List[Project]],
        Field(description='List of projects for the authenticated user.'),
    ] = None
    versions: Annotated[
        Optional[List[LeanVersion]], Field(description='List of LEAN versions.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ProjectNodesResponse(BaseModel):
    nodes: Annotated[
        Optional[ProjectNodes], Field(description='List of project nodes.')
    ] = None
    autoSelectNode: Annotated[
        Optional[bool],
        Field(
            description='Indicate if the best-performing node is automatically selected.'
        ),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ReadChartResponse(BaseModel):
    chart: Annotated[Optional[Chart], Field(description='Chart object requested.')] = (
        None
    )
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ReadOptimizationResponse(BaseModel):
    optimization: Annotated[
        Optional[Optimization],
        Field(description='Optimization object requested to read.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class InlineResponse200(BaseModel):
    RootModel: Any


class InlineResponse2001(BaseModel):
    RootModel: Any


class InlineResponse2003(BaseModel):
    RootModel: Any


class BacktestOrdersResponse(BaseModel):
    orders: Optional[Dict[str, Order]] = None
    length: Annotated[
        Optional[int], Field(description='Total number of returned orders')
    ] = None


class BacktestResponse(BaseModel):
    backtest: Annotated[
        Optional[List[BacktestResult]],
        Field(description='Collection of backtests for a project.'),
    ] = None
    debugging: Annotated[
        Optional[bool],
        Field(description='Indicates if the backtest is run under debugging mode.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class BacktestSummaryResponse(BaseModel):
    backtest: Annotated[
        Optional[List[BacktestSummaryResult]],
        Field(description='Collection of backtest summaries for a project.'),
    ] = None
    count: Annotated[
        Optional[int],
        Field(description='Number of backtest summaries retrieved in the response.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class BacktestListModel(BaseModel):
    backtests: Annotated[
        Optional[List[BacktestResponse]],
        Field(description='Array of BacktestResponse objects'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class CreateCompileResponse(BaseModel):
    compileId: Annotated[
        Optional[str],
        Field(
            description='Compile Id for a sucessful build.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ] = None
    state: Annotated[
        Optional[State], Field(description='The current state of the compile job.')
    ] = None
    parameters: Annotated[
        Optional[List[FileParameters]],
        Field(
            description='List of files and their associated parameters detected during compilation.'
        ),
    ] = None
    projectId: Annotated[
        Optional[int],
        Field(
            description='Id of the project you requested to compile.',
            examples=[23456789],
        ),
    ] = None
    signature: Annotated[
        Optional[str], Field(description='Signature key of compilation.')
    ] = None
    signatureOrder: Annotated[
        Optional[List[str]],
        Field(description='Signature order of files to be compiled.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class LiveOrdersResponse(BaseModel):
    orders: Annotated[
        Optional[List[Order]], Field(description='Collection of orders.')
    ] = None
    length: Annotated[
        Optional[int], Field(description='Total number of returned orders')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None
